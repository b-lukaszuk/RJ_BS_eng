<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Bartlomiej Lukaszuk" />
  <title>Statistics intro - Solutions - Romeo and Julia</title>
  <link rel="stylesheet" href="./style.css"/>
    <script src="./mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("./JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./github.min.css">
<script src="./highlight.min.js"></script>
<script src="./julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="./">Romeo and Julia</a>
</div><br />
<span class="books-subtitle">
where Romeo is Basic Statistics
</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="./about.html"><b>1</b> About</a></li>
<li><a class="menu-level-1" href="./why_julia.html"><b>2</b> Why Julia</a></li>
<li><a class="menu-level-2" href="./julia_is_fast.html"><b>2.1</b> Julia is fast</a></li>
<li><a class="menu-level-2" href="./julia_is_simple.html"><b>2.2</b> Julia is simple</a></li>
<li><a class="menu-level-2" href="./jl_pleasure_to_write.html"><b>2.3</b> Pleasure to write</a></li>
<li><a class="menu-level-2" href="./jl_not_mainstream.html"><b>2.4</b> Not mainstream</a></li>
<li><a class="menu-level-2" href="./jl_open_source.html"><b>2.5</b> Julia is free</a></li>
<li><a class="menu-level-1" href="./julia_first_encounter.html"><b>3</b> Julia - first encounter</a></li>
<li><a class="menu-level-2" href="./julia_installation.html"><b>3.1</b> Installation</a></li>
<li><a class="menu-level-2" href="./julia_language_constructs.html"><b>3.2</b> Language Constructs</a></li>
<li><a class="menu-level-2" href="./julia_language_variables.html"><b>3.3</b> Variables</a></li>
<li><a class="menu-level-2" href="./julia_language_functions.html"><b>3.4</b> Functions</a></li>
<li><a class="menu-level-2" href="./julia_language_decision_making.html"><b>3.5</b> Decision Making</a></li>
<li><a class="menu-level-2" href="./julia_language_repetition.html"><b>3.6</b> Repetition</a></li>
<li><a class="menu-level-2" href="./julia_language_libraries.html"><b>3.7</b> Additional libraries</a></li>
<li><a class="menu-level-2" href="./julia_language_exercises.html"><b>3.8</b> Julia - Exercises</a></li>
<li><a class="menu-level-2" href="./julia_language_exercises_solutions.html"><b>3.9</b> Julia - Solutions</a></li>
<li><a class="menu-level-1" href="./statistics_intro.html"><b>4</b> Statistics - introduction</a></li>
<li><a class="menu-level-2" href="./statistics_intro_imports.html"><b>4.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./statistics_intro_probability_definition.html"><b>4.2</b> Probability - definition</a></li>
<li><a class="menu-level-2" href="./statistics_intro_probability_properties.html"><b>4.3</b> Probability - properties</a></li>
<li><a class="menu-level-2" href="./statistics_prob_theor_practice.html"><b>4.4</b> Probability - theory and..</a></li>
<li><a class="menu-level-2" href="./statistics_prob_distribution.html"><b>4.5</b> Probability distribution</a></li>
<li><a class="menu-level-2" href="./statistics_normal_distribution.html"><b>4.6</b> Normal distribution</a></li>
<li><a class="menu-level-2" href="./statistics_intro_hypothesis_testing.html"><b>4.7</b> Hypothesis testing</a></li>
<li><a class="menu-level-2" href="./statistics_intro_exercises.html"><b>4.8</b> Statistics intro - Exerc..</a></li>
<li><a class="menu-level-2" href="./statistics_intro_exercises_solutions.html"><b>4.9</b> Statistics intro - Solut..</a></li>
<li><a class="menu-level-1" href="./appendix.html"><b></b> Appendix</a></li>
<li><a class="menu-level-1" href="./references.html"><b>5</b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="4.9" id="sec:statistics_intro_exercises_solutions"><span class="header-section-number">4.9</span> Statistics intro - Solutions</h2>
<p>In this sub-chapter you will find examplary solutions to the exercises from the previous section.</p>
<h3 data-number="4.9.1" id="sec:statistics_intro_exercise1_solution"><span class="header-section-number">4.9.1</span> Solution to Exercise 1</h3>
<p>The easiest way to solve this problem is to reduce it to a simpler one.</p>
<p>If the PIN number were only 1-digit, then the total number of possibilities would be equal to 10 (numbers from 0 to 9).</p>
<p>For a 2-digit PIN the pattern would be as follow:</p>
<pre>
00
01
02
...
09
10
11
12
...
19
20
21
...
98
99
</pre>
<p>So, for every number in the first location there are 10 numbers (0-9) in the second location. Therefore in total we got numbers in the range 00-99, or to write it mathematically 10 * 10 different numbers (numbers per pos. 1 * numbers per pos. 2).</p>
<p>By extension the total number of possibilities for a 4-digit PIN is:</p>
<pre class="language-julia"><code># (method1, method2, method3)
(10 * 10 * 10 * 10, 10^4, length(0:9999))</code></pre>
<pre class="output"><code>(10000, 10000, 10000)</code></pre>
<p>So 10’000 numbers. Therefore the probability for a random number being the right one is <code>1/10_000</code> = 0.0001</p>
<p>Similar methodology is used to assess the strength of a password to an internet website.</p>
<h3 data-number="4.9.2" id="sec:statistics_intro_exercise2_solution"><span class="header-section-number">4.9.2</span> Solution to Exercise 2</h3>
<p>OK, so let’s reduce the problem before we solve it.</p>
<p>If I had only 1 beer and 1 label then there is only one way to do it. The label in my hand goes to the beer in front of me.</p>
<p>For 2 labels and 2 beer it goes like this:</p>
<pre>
a b
b a
</pre>
<p>I place one of two labels on a first beer, and I’m left with only 1 label for the second beer. So, 2 possibilities in total.</p>
<p>For 3 labels and 3 beer the possibilities are as follow:</p>
<pre>
a b c
a c b

b a c
b c a

c a b
c b a
</pre>
<p>So here, for the first beer I can assign any of the three labels (<code>a</code>, <code>b</code>, or <code>c</code>). Then I move to the second beer and have only two labels left in my hand (if the first got <code>a</code>, then the second can get only <code>b</code> or <code>c</code>). Then I move to the last beer with the last label in my hand (if the first two were <code>a</code> and <code>b</code> then I’m left with <code>c</code>). In total I got <code>3 * 2 * 1</code> = 6 possibilities.</p>
<p>It turns out this relationship holds also for bigger numbers. In mathematics it can be calculated using <a href="https://en.wikipedia.org/wiki/Factorial">factorial</a> function that is already implemented in Julia (see <a href="https://docs.julialang.org/en/v1/base/math/#Base.factorial">the docs</a>).</p>
<p>For practice I’m gonna solve it using the classic idiom of <a href="https://en.wikipedia.org/wiki/Recursion">recursion</a>.</p>
<pre class="language-julia"><code>function myFactorial(n::Int)::Int
    @assert n &gt; 0 &quot;n must be positive&quot;
    if n == 1
        return 1
    else
        return n * myFactorial(n-1)
    end
end

myFactorial(6)</code></pre>
<p>720</p>
<blockquote>
<p><strong><em>Note:</em></strong> Recursion is often elegant and fast to implement but not very computationally efficient way to solve a problem (especially ineffective for large problems).</p>
</blockquote>
<p>As you can see here a function calls itself. In order to implement a recursive function correctly we need to follow 2 rules:</p>
<ul>
<li>know when to stop (<code>if n == 1</code> then <code>return 1</code>)</li>
<li>separate a problem into a part (<code>n *</code>) and a smaller problem (<code>myFactorial(n-1)</code>)</li>
</ul>
<p>If the above seems to be difficult at the moment you may try, e.g with a more familiar version that uses <code>foreach</code> (we met it in Section <a href="./julia_language_repetition.html#sec:julia_language_map_foreach">3.6.5</a>)</p>
<pre class="language-julia"><code>function myFactorial2(n::Int)::Int
    @assert n &gt; 0 &quot;n must be positive&quot;
    product::Int = 1
    foreach(x -&gt; product *= x, 1:n)
    return product
end

myFactorial2(6)</code></pre>
<p>720</p>
<blockquote>
<p><strong><em>Note:</em></strong> You may also just use Julia’s <a href="https://docs.julialang.org/en/v1/base/collections/#Base.prod">prod</a> function, e.g. <code>prod(1:6)</code> = 720.</p>
</blockquote>
<p>So, the probability that a person correctly labels 6 beer at random is <code>round(1/factorial(6), digits=5)</code> = 0.00139.</p>
<p>I guess that is the reason why out of 7 people that attempted to correctly label 6 beer the results were as follows:</p>
<ul>
<li>one person correctly labeled 0 beer</li>
<li>five people correctly labeled 1 beer</li>
<li>one person correctly labeled 2 beer</li>
</ul>
<p>I leave the conclusions to you.</p>
<h3 data-number="4.9.3" id="sec:statistics_intro_exercise3_solution"><span class="header-section-number">4.9.3</span> Solution to Exercise 3</h3>
<p>OK, for the original tennis example (see Section <a href="./statistics_intro_hypothesis_testing.html#sec:statistics_intro_tennis">4.7.1</a>) we answered the question by using a computer simulation first (Section <a href="./statistics_intro_hypothesis_testing.html#sec:statistics_intro_tennis_comp_simul">4.7.2</a>). For a change, this time we will start with a ’purely mathematical` calculations. Ready?</p>
<p>In order to get the result of 1-5 for Peter we would have to get a series of games like this one:</p>
<pre>
# 0 - John's victory, 1 - Peter's victory
0 1 1 1 1 1
</pre>
<p>Probability of either John or Peter winning under <span class="math inline">\(H_{0}\)</span> (assumption that they play equally well) is <span class="math inline">\(\frac{1}{2}\)</span> = 0.5. So here we got a conjunction of probabilities (John won AND Peter won AND Peter won AND …). According to what we’ve learned in Section <a href="./statistics_intro_probability_properties.html#sec:statistics_intro_probability_summary">4.3.1</a>) we should multiply the probabilities by each other.</p>
<p>Therefore, the probability of the result above is <code>0.5 * 0.5 * 0.5 * ...</code> or <code>0.5 ^ 6</code> = 0.015625. But wait, there’s more. We can get such a result (1-5 for Peter) in a few different ways, i.e.</p>
<pre>
0 1 1 1 1 1
# or
1 0 1 1 1 1
# or
1 1 0 1 1 1
# or
1 1 1 0 1 1
# or
1 1 1 1 0 1
# or
1 1 1 1 1 0
</pre>
<blockquote>
<p><strong><em>Note:</em></strong> For a big number of games it is tedious and boring to write all the possibilities by hand. In this case you may use Julia’s <a href="https://docs.julialang.org/en/v1/base/math/#Base.binomial">binomial</a> funcion, e.g. <code>binomial(6, 5)</code> = 6. This tells us how many different fives of six objects can we get.</p>
</blockquote>
<p>As we said a moment ago, each of this series of games occurs with the probability of 0.015625. Since we used OR (see the coments in the code above) then according to Section <a href="./statistics_intro_probability_properties.html#sec:statistics_intro_probability_summary">4.3.1</a> we can add 0.015625 six times to itself (or multiply it by 6). So, the probability is equal to:</p>
<pre class="language-julia"><code>prob1to5 = (0.5^6) * 6 # parenthesis were placed for the sake of clarity
prob0to6 = 0.5^6
probBothOneTail = prob1to5 + prob0to6

probBothOneTail</code></pre>
<p>0.109375</p>
<p>Of course we must remember what our imaginary statistician said in Section <a href="./statistics_intro_hypothesis_testing.html#sec:statistics_intro_tennis">4.7.1</a>: “I assume that <span class="math inline">\(H_{0}\)</span> is true. Then I will conduct the experiment and record then result. I will calculate the probability of such a result (or more extreme result) happening by chance.”</p>
<p><code>More extreme</code> than 1-5 for Peter is 0-6 for Peter, we previously (see Section <a href="./statistics_intro_hypothesis_testing.html#sec:statistics_intro_tennis_theor_calc">4.7.3</a>) calculated it to be <code>0.5^6</code> = 0.015625. Finally, we can get our p-value (for one-tailed test)</p>
<pre class="language-julia"><code>prob1to5 = (0.5^6) * 6 # parenthesis were placed for the sake of clarity
prob0to6 = 0.5^6
probBothOneTail = prob1to5 + prob0to6

probBothOneTail</code></pre>
<p>0.109375</p>
<blockquote>
<p><strong><em>Note:</em></strong> Once you get used to calculating probabilities you should use quick methods like those from <code>Distributions</code> package (presented below), but for now it is important to understand what happens here, hence those long calculations (of <code>probBothOneTail</code>) presented here.</p>
</blockquote>
<p>Let’s quickly verify it with other methods we met before (e.g. in Section <a href="./statistics_intro_hypothesis_testing.html#sec:statistics_intro_hypothesis_testing">4.7</a>)</p>
<pre class="language-julia"><code># for better clarity each method is in a separate line
(
probBothOneTail,
1 - dsts.cdf(dsts.Binomial(6, 0.5), 4),
dsts.pdf.(dsts.Binomial(6, 0.5), 5:6) |&gt; sum,
tennisProbs[5] + tennisProbs[6] # experimental probability
)</code></pre>
<pre class="output"><code>(0.109375, 0.109375, 0.10937499999999988, 0.11052000000000001)</code></pre>
<p>Yep, they all appear the same (remember about floats rounding and the difference between theory and practice from Section <a href="./statistics_prob_theor_practice.html#sec:statistics_prob_theor_practice">4.4</a>).</p>
<p>So, is it significant at the crazy cutoff level of <span class="math inline">\(\alpha = 0.15\)</span>?</p>
<pre class="language-julia"><code>shouldRejectH0(probBothOneTail, 0.15)</code></pre>
<p>true</p>
<p>Yes, it is (we reject <span class="math inline">\(H_{0}\)</span> on favor of <span class="math inline">\(H_{A}\)</span>). And now for the two-tailed test.</p>
<pre class="language-julia"><code># remember the probability distribution is symmetrical, so *2 is OK here
shouldRejectH0(probBothOneTail * 2, 0.15)</code></pre>
<p>false</p>
<p>Here we cannot reject our <span class="math inline">\(H_{0}\)</span>.</p>
<p>Of course we all remember that this was just for practice, because the acceptable type I error cutoff level is usually 0.05 or 0.01. In this case, according to both the one-tailed and two-tailed tests we failed to reject the <span class="math inline">\(H_{0}\)</span>.</p>
<p>BTW, this shows how important is a strict mathematical reasoning and adhering to our own methodology. I don’t know about you but when I were a student I would have had probably accepted the result 1-5 for Peter as an intuitive evidence that he is a better tennis player.</p>
<p>To be continued…</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="./statistics_intro_exercises.html"><b>4.8</b> Statistics intro - Exerc..</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="./appendix.html"><b></b> Appendix</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Bartlomiej Lukaszuk
</div>
</div>
</div>
</body>
</html>