<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Bartlomiej Lukaszuk" />
  <title>Repetition - Romeo and Julia</title>
  <link rel="stylesheet" href="./style.css"/>
    <script src="./mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("./JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./github.min.css">
<script src="./highlight.min.js"></script>
<script src="./julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="./">Romeo and Julia</a>
</div><br />
<span class="books-subtitle">
where Romeo is Basic Statistics
</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="./about.html"><b>1</b> About</a></li>
<li><a class="menu-level-1" href="./why_julia.html"><b>2</b> Why Julia</a></li>
<li><a class="menu-level-2" href="./julia_is_fast.html"><b>2.1</b> Julia is fast</a></li>
<li><a class="menu-level-2" href="./julia_is_simple.html"><b>2.2</b> Julia is simple</a></li>
<li><a class="menu-level-2" href="./jl_pleasure_to_write.html"><b>2.3</b> Pleasure to write</a></li>
<li><a class="menu-level-2" href="./jl_not_mainstream.html"><b>2.4</b> Not mainstream</a></li>
<li><a class="menu-level-2" href="./jl_open_source.html"><b>2.5</b> Julia is free</a></li>
<li><a class="menu-level-1" href="./julia_first_encounter.html"><b>3</b> Julia - first encounter</a></li>
<li><a class="menu-level-2" href="./julia_installation.html"><b>3.1</b> Installation</a></li>
<li><a class="menu-level-2" href="./julia_language_constructs.html"><b>3.2</b> Language Constructs</a></li>
<li><a class="menu-level-2" href="./julia_language_variables.html"><b>3.3</b> Variables</a></li>
<li><a class="menu-level-2" href="./julia_language_functions.html"><b>3.4</b> Functions</a></li>
<li><a class="menu-level-2" href="./julia_language_decision_making.html"><b>3.5</b> Decision Making</a></li>
<li><a class="menu-level-2" href="./julia_language_repetition.html"><b>3.6</b> Repetition</a></li>
<li><a class="menu-level-2" href="./julia_language_libraries.html"><b>3.7</b> Additional libraries</a></li>
<li><a class="menu-level-2" href="./julia_language_exercises.html"><b>3.8</b> Julia - Exercises</a></li>
<li><a class="menu-level-2" href="./julia_language_exercises_solutions.html"><b>3.9</b> Julia - Solutions</a></li>
<li><a class="menu-level-1" href="./statistics_intro.html"><b>4</b> Statistics - introduction</a></li>
<li><a class="menu-level-2" href="./statistics_intro_imports.html"><b>4.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./statistics_intro_probability_definition.html"><b>4.2</b> Probability - definition</a></li>
<li><a class="menu-level-2" href="./statistics_intro_probability_properties.html"><b>4.3</b> Probability - properties</a></li>
<li><a class="menu-level-2" href="./statistics_prob_theor_practice.html"><b>4.4</b> Probability - theory and..</a></li>
<li><a class="menu-level-2" href="./statistics_prob_distribution.html"><b>4.5</b> Probability distribution</a></li>
<li><a class="menu-level-2" href="./statistics_normal_distribution.html"><b>4.6</b> Normal distribution</a></li>
<li><a class="menu-level-2" href="./statistics_intro_hypothesis_testing.html"><b>4.7</b> Hypothesis testing</a></li>
<li><a class="menu-level-2" href="./statistics_intro_exercises.html"><b>4.8</b> Statistics intro - Exerc..</a></li>
<li><a class="menu-level-2" href="./statistics_intro_exercises_solutions.html"><b>4.9</b> Statistics intro - Solut..</a></li>
<li><a class="menu-level-1" href="./compare_contin_data.html"><b>5</b> Comparisons - continuous d..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_imports.html"><b>5.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_one_samp_ttest.html"><b>5.2</b> One sample Student’s t..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_two_samp_ttest.html"><b>5.3</b> Two sample Student’s t..</a></li>
<li><a class="menu-level-1" href="./appendix.html"><b></b> Appendix</a></li>
<li><a class="menu-level-1" href="./references.html"><b>6</b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="3.6" id="sec:julia_language_repetition"><span class="header-section-number">3.6</span> Repetition</h2>
<p>Julia, and computers in general, are good at doing boring, repetitive tasks for us without a word of complaint (and they do it much faster than we do). Let’s see some constructs that help us with it.</p>
<h3 data-number="3.6.1" id="sec:julia_language_for_loops"><span class="header-section-number">3.6.1</span> For loops</h3>
<p>A <a href="https://en.wikipedia.org/wiki/For_loop">for loop</a> is a standard construct present in many programming languages that do the repetition for us. Its general form in Julia is:</p>
<pre><code># pseudocode, do not run this snippet
for i in sequence
    # do_something_useful
end</code></pre>
<p>The loop is enclosed between <code>for</code> and <code>end</code> keywords and repeats some specific action(s) (<code># do_something_useful</code>) for every element of a <code>sequence</code>. On each turnover of a loop consecutive elements of a sequence are referred to by <code>i</code>.</p>
<blockquote>
<p><strong><em>Note:</em></strong> I could have assigned any name, like: <code>j</code>, <code>k</code>, <code>whatever</code>, it would work the same. Still, <code>i</code> and <code>j</code> are quite common in <a href="https://en.wikipedia.org/wiki/For_loop">for loops</a>.</p>
</blockquote>
<p>Let’s say I want a program that will print <a href="https://en.wikipedia.org/wiki/Hip_hip_hooray">hip hip hooray</a> many times for my friend that celebrates some success. I can proceed like this.</p>
<pre class="language-julia"><code>function printHoorayNtimes(n::Int)
    @assert (n &gt; 0) &quot;n needs to be greater than 0&quot;
    for _ in 1:n
        println(&quot;hip hip hooray!&quot;)
    end
    return nothing
end</code></pre>
<p>Go ahead, run it (e.g. <code>printHoorayNtimes(3)</code>).</p>
<p>Notice two new elements. Here it makes no sense for <code>n</code> to be less than or equal to 0. Hence, I used <a href="https://docs.julialang.org/en/v1/base/base/#Base.@assert">@assert</a> construct to test it and print an error message (<code>"n needs to be greater than 0"</code>) if it is. The <code>1:n</code> is a range similar to the one we used in Section <a href="./julia_language_variables.html#sec:julia_vectors">3.3.6</a>. Here, I used <code>_</code> instead of <code>i</code> in the example above (to signal that I don’t plan to use it further).</p>
<p>OK, how about another example. You remember <code>myMathGrades</code>, right?</p>
<pre class="language-julia"><code>myMathGrades = [3.5, 3.0, 3.5, 2.0, 4.0, 5.0, 3.0]</code></pre>
<p>Now, since the end of the school year is coming then I would like to know my <a href="https://en.wikipedia.org/wiki/Arithmetic_mean">average</a> (likely this will be my final grade). In order to get that I need to divide the sum by the number of grades. First the sum.</p>
<pre class="language-julia"><code>function getSum(nums::Vector{&lt;:Real})::Real
    total::Real = 0
    for i in 1:length(nums)
        total = total + nums[i]
    end
    return total
end

getSum(myMathGrades)</code></pre>
<p>24.0</p>
<p>A few explanations regarding the new bits of code here.</p>
<p>In arguments list I wrote <code>::Vector{&lt;:Real}</code>. Which means that each element of nums is a subtype (<code>&lt;:</code>) of the type <code>Real</code> (which includes integers and floats). I declared a <code>total</code> and initialized it to 0. Then in <code>for</code> loop I used <code>i</code> to hold numbers from 1 to number of elements in the vector (<code>length(nums)</code>). Finally, in the for loop body I added each number from the vector (using indexing see Section <a href="./julia_language_variables.html#sec:julia_vectors">3.3.6</a>) to the <code>total</code>. The <code>total = total + nums[i]</code> means that new total is equal to old total + element of the vector with index <code>i</code>. Finally, I returned the total.</p>
<p>The body of the <code>for</code> loop could be improved. Instead of <code>for i in 1:length(nums)</code> I could have written <code>for i in eachindex(nums)</code> (notice there is no <code>1:</code>, eachindex is a build-in Julia function, see <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.eachindex">here</a>). Moreover, instead of <code>total = total + nums[i]</code> I could have used <code>total += nums[i]</code>. The <code>+=</code> is and <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#Updating-operators">update operator</a>, i.e. a shortcut for updating old value by adding a new value to it. Take a moment to rewrite the function with those new forms and test it.</p>
<p>Alternatively, I can do this without indexing (although <code>for</code> loops with indexing are a kind of classical idiom in programming and it is worth to know them).</p>
<pre class="language-julia"><code>function getSum(nums::Vector{&lt;:Real})::Real
    total::Real = 0
    for num in nums
        total += num
    end
    return total
end

getSum(myMathGrades)</code></pre>
<p>24.0</p>
<p>Here <code>num</code> (I could have used <code>n</code>, <code>i</code> or <code>whatever</code> if I wanted to) takes the value of each consecutive element of <code>nums</code> and adds it to the total.</p>
<p>OK, and now back to the <a href="https://en.wikipedia.org/wiki/Arithmetic_mean">average</a>.</p>
<pre class="language-julia"><code>function getAvg(nums::Vector{&lt;:Real})::Real
    return getSum(nums) / length(nums)
end

getAvg(myMathGrades)</code></pre>
<p>3.4285714285714284</p>
<p>Ups, not quite 3.5, I’ll better present some additional projects to improve my final grade.</p>
<p>OK, two more examples that might be useful and will help you master <code>for</code> loops even better.</p>
<p>Let’s say I got a vector of temperatures in <a href="https://en.wikipedia.org/wiki/Celsius">Celsius</a> and want to send it to a friend in the US.</p>
<pre class="language-julia"><code>temperaturesCelsius = [22, 18.3, 20.1, 19.5]</code></pre>
<pre class="output"><code>[22.0, 18.3, 20.1, 19.5]</code></pre>
<p>To make it easier for him I should probably change it to <a href="https://en.wikipedia.org/wiki/Fahrenheit">Fahrenheit</a> using <a href="https://en.wikipedia.org/wiki/Fahrenheit#Conversion_(specific_temperature_point)">this formula</a>. I start with writing simple converting function for a single value of the temperature in Celsius.</p>
<pre class="language-julia"><code>function degCels2degFahr(tempCels::Real)::Real
    return tempCels * 1.8 + 32
end

degCels2degFahr(0)</code></pre>
<p>32.0</p>
<p>Now let’s convert the temperatures in the vector. First I would try something like this:</p>
<pre class="language-julia"><code>function degCels2degFahr!(tempsCels::Vector{&lt;:Real})
    for i in eachindex(tempsCels)
        tempsCels[i] = degCels2degFahr(tempsCels[i])
    end
    return nothing
end</code></pre>
<p>Notice the <code>!</code> in the function name (don’t remember what it mean? <a href="https://docs.julialang.org/en/v1/manual/style-guide/#bang-convention">see here</a>).</p>
<p>Still, this is not good. If I use it (<code>degCels2degFahr!(temperatureCelsius)</code>) it will change the values in <code>temperaturesCelsius</code> to Fahrenheit which could cause problems (variable name doesn’t reflect its contents). A better approach is to write a function that produces a new vector and doesn’t change the old one.</p>
<pre class="language-julia"><code>function degCels2degFahr(tempsCels::Vector{&lt;:Real})::Vector{&lt;:Real}
    result::Vector{&lt;:Real} = zeros(length(tempsCels))
    for i in eachindex(tempsCels)
        result[i] = degCels2degFahr(tempsCels[i])
    end
    return result
end</code></pre>
<pre class="output"><code>degCels2degFahr (generic function with 2 methods)</code></pre>
<p>Now I can use it like that:</p>
<pre class="language-julia"><code>temperaturesFahrenheit = degCels2degFahr(temperaturesCelsius)</code></pre>
<pre class="output"><code>[71.6, 64.94, 68.18, 67.1]</code></pre>
<p>First of all, notice that so far I defined two functions named <code>degCels2degFahr</code>. One of them has got a single value as an argument (<code>degCels2degFahr(tempCels::Real)</code>) and another a vector as its argument (<code>degCels2degFahr(tempsCels::Vector{&lt;:Real})</code>). But since I explicitly declared argument types, Julia will know when to use each version (see next paragraph).</p>
<p>In the body of <code>degCels2degFahr(tempsCels::Vector{&lt;:Real})</code> first I declare and initialize a variable that will hold the result (hence <code>result</code>). I do this using build in <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.zeros">zeros</a> function. The function returns a new vector with n elements (where n is equal to <code>length(tempsCels)</code>) filled with, you got it, 0s. The 0s are just placeholders. Then, in the <code>for</code> loop, I go through all the indices of <code>result</code> (<code>i</code> holds the current index) and replace each zero (<code>result[i]</code>) with a corresponding value in Fahrenheit (<code>degCels2degFahr(tempsCels[i])</code>). Here, since I pass a single value (<code>tempsCels[i]</code>) Julia knows which version (aka method) of the function <code>degCels2degFahr</code> to use (i.e. this one <code>degCels2degFahr(tempCels::Real)</code>).</p>
<p>OK, enough for the classic <code>for</code> loops. Let’s go to some build-in goodies that could help us out with repetition.</p>
<h3 data-number="3.6.2" id="sec:julia_language_buildin_goodies"><span class="header-section-number">3.6.2</span> Build-in Goodies</h3>
<p>If the operation you want to perform is simple enough you may prefer to use some Julia goodies.</p>
<h3 data-number="3.6.3" id="sec:julia_language_reduce"><span class="header-section-number">3.6.3</span> Reduce</h3>
<p>Remember the <code>getSum</code> function that we wrote previously. Well, it can be made shorter by using <a href="https://docs.julialang.org/en/v1/base/collections/#Base.reduce-Tuple%7BAny,%20Any%7D">reduce</a>.</p>
<pre class="language-julia"><code>xs = [1, 2, 3]

function getSum(nums::Vector{&lt;:Real})::Real
    return reduce((x, y) -&gt; x + y, xs, init=0)
end

getSum(xs)</code></pre>
<p>6</p>
<p>As you can see <code>reduce</code> accepts 3 arguments: a function, a collection, and initial value. Here, I used so called <a href="https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions">anonymous function</a>, so a function without name. The expression <code>(x, y) -&gt; x + y</code> means a function that takes two arguments and returns their sum. The <code>reduce</code> takes this function and executes it many times, each time:</p>
<ol type="1">
<li>one argument is <code>init</code> (if executed for the first time) or the result of previous execution</li>
<li>the other argument is consecutive element of the collection</li>
</ol>
<p>So, in the case above I imagine it does something like:</p>
<pre><code># pseudocode, do not execute this snippet
# call: reduce((x, y) -&gt; x + y, [1, 2, 3], init=0)
0 + 1 # (init + current element), result: 1
1 + 2 # (previous result + current element), result: 3
3 + 3 # (previous result + current element), result: 6
# no more elements left, the result of the last operation is returned</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> The order of <code>+</code> operation is not guaranteed, e.g. it could go innit/result + current or current + innit/result.</p>
</blockquote>
<p>In this case <code>reduce</code> could be further simplified, but I assume you already have a lot to wrap your head around so I leave it as it is. Just remember to type <code>init=</code> and then the default argument (not the value alone, since it is a <a href="https://docs.julialang.org/en/v1/manual/functions/#Keyword-Arguments">keyword argument</a>).</p>
<h3 data-number="3.6.4" id="sec:julia_language_comprehensions"><span class="header-section-number">3.6.4</span> Comprehensions</h3>
<p>Another useful constructs are <a href="https://docs.julialang.org/en/v1/manual/arrays/#man-comprehensions">comprehensions</a>.</p>
<p>Let’s say this time I want to convert inches to centimeters using this function.</p>
<pre class="language-julia"><code>function inch2cm(inch::Real)::Real
    return inch * 2.54
end

inch2cm(1)</code></pre>
<p>2.54</p>
<p>If I want to do it for a bunch of values I can use comprehensions like so.</p>
<pre class="language-julia"><code>inches = [10, 20, 30]

function inches2cms(inches::Vector{&lt;:Real})::Vector{&lt;:Real}
    return [inch2cm(inch) for inch in inches]
end

inches2cms(inches)</code></pre>
<pre class="output"><code>[25.4, 50.8, 76.2]</code></pre>
<p>On the right I use the familiar <code>for</code> loop syntax, i.e. <code>for sth in collection</code>. On the left I place a function (named or anonymous) that I want to use and pass consecutive elements (<code>sth</code>) to that function. The expression is surrounded with square brackets so that Julia makes a new vector out of it (the old vector is not changed).</p>
<p><em>In general comprehensions are pretty useful, chances are that I’m going to use them a lot in this book so make sure to learn them.</em></p>
<h3 data-number="3.6.5" id="sec:julia_language_map_foreach"><span class="header-section-number">3.6.5</span> Map and Foreach</h3>
<p>Comprehensions are nice, but some people find <a href="https://docs.julialang.org/en/v1/base/collections/#Base.map">map</a> even better. The example above could be rewritten as:</p>
<pre class="language-julia"><code>inches = [10, 20, 30]

function inches2cms(inches::Vector{&lt;:Real})::Vector{&lt;:Real}
    return map(inch2cm, inches)
end

inches2cms(inches)</code></pre>
<pre class="output"><code>[25.4, 50.8, 76.2]</code></pre>
<p>Again, I pass function (note I typed only its name) as a first argument to <code>map</code>, the second argument is a collection. Map automatically applies the function to every element of the collection and returns a new collection. Isn’t this magic.</p>
<p>If you want to evoke a function on a vector just for side effects (does not return/build a vector) use <a href="https://docs.julialang.org/en/v1/base/collections/#Base.foreach">foreach</a>. For instance, <code>getSum</code> with <code>foreach</code> and an anonymous function would look like this</p>
<pre class="language-julia"><code>function getSum(vect::Vector{&lt;:Real})::Real
    total::Real = 0
    foreach(x -&gt; total += x, vect) # side effect is to increase total
    return total
end

getSum([1, 2, 3, 4])</code></pre>
<p>10</p>
<h3 data-number="3.6.6" id="sec:julia_language_dot_functions"><span class="header-section-number">3.6.6</span> Dot operators/functions</h3>
<p>Last but not least. I can use a <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#man-dot-operators">dot operator</a>. Say I got a vector of numbers and I want to add 10 to each of them. Doing this for a single number is simple, I would have just typed <code>1 + 10</code>. Hmm, but for a vector? Simple as well. I just need to precede the operator with a <code>.</code> like so:</p>
<pre class="language-julia"><code>[1, 2, 3] .+ 10</code></pre>
<pre class="output"><code>[11, 12, 13]</code></pre>
<p>I can do this also for functions (both build-in and written by myself). Notice <code>.</code> goes before <code>(</code></p>
<pre class="language-julia"><code>inches = [10, 20, 30]

function inches2cms(inches::Vector{&lt;:Real})::Vector{&lt;:Real}
    return inch2cm.(inches)
end

inches2cms(inches)</code></pre>
<pre class="output"><code>[25.4, 50.8, 76.2]</code></pre>
<p>Isn’t this nice.</p>
<p>OK, the goodies are great, but require some time to get used to them (I suspect at first you’re gonna use good old <code>for</code> loop syntax). Besides the constructs described in this section are good for simple operations (don’t try to put too much logic into them, they are supposed to be one liners).</p>
<p>In any case choose a construct that you know how to use and that gets the job done for you, mastering them all will take some time.</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="./julia_language_decision_making.html"><b>3.5</b> Decision Making</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="./julia_language_libraries.html"><b>3.7</b> Additional libraries</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Bartlomiej Lukaszuk
</div>
</div>
</div>
</body>
</html>