<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Bartlomiej Lukaszuk" />
  <title>Functions - Romeo and Julia, where Romeo is Basic Statistics</title>
  <link rel="stylesheet" href="./style.css"/>
    <script src="./mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("./JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./github.min.css">
<script src="./highlight.min.js"></script>
<script src="./julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="./">Romeo and Julia, where Romeo is Basic Statistics</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="./about.html"><b>1</b> About</a></li>
<li><a class="menu-level-1" href="./why_julia.html"><b>2</b> Why Julia</a></li>
<li><a class="menu-level-2" href="./julia_is_fast.html"><b>2.1</b> Julia is fast</a></li>
<li><a class="menu-level-2" href="./julia_is_simple.html"><b>2.2</b> Julia is simple</a></li>
<li><a class="menu-level-2" href="./jl_pleasure_to_write.html"><b>2.3</b> Pleasure to write</a></li>
<li><a class="menu-level-2" href="./jl_not_mainstream.html"><b>2.4</b> Not mainstream</a></li>
<li><a class="menu-level-2" href="./jl_open_source.html"><b>2.5</b> Julia is free</a></li>
<li><a class="menu-level-1" href="./julia_first_encounter.html"><b>3</b> Julia - first encounter</a></li>
<li><a class="menu-level-2" href="./julia_installation.html"><b>3.1</b> Installation</a></li>
<li><a class="menu-level-2" href="./julia_language_constructs.html"><b>3.2</b> Language Constructs</a></li>
<li><a class="menu-level-2" href="./julia_language_variables.html"><b>3.3</b> Variables</a></li>
<li><a class="menu-level-2" href="./julia_language_functions.html"><b>3.4</b> Functions</a></li>
<li><a class="menu-level-2" href="./julia_language_decision_making.html"><b>3.5</b> Decision Making</a></li>
<li><a class="menu-level-2" href="./julia_language_repetition.html"><b>3.6</b> Repetition</a></li>
<li><a class="menu-level-2" href="./julia_language_libraries.html"><b>3.7</b> Additional libraries</a></li>
<li><a class="menu-level-2" href="./julia_language_exercises.html"><b>3.8</b> Julia - Exercises</a></li>
<li><a class="menu-level-2" href="./julia_language_exercises_solutions.html"><b>3.9</b> Julia - Solutions</a></li>
<li><a class="menu-level-1" href="./statistics_intro.html"><b>4</b> Statistics - introduction</a></li>
<li><a class="menu-level-2" href="./statistics_intro_imports.html"><b>4.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./statistics_intro_probability_definition.html"><b>4.2</b> Probability - definition</a></li>
<li><a class="menu-level-2" href="./statistics_intro_probability_properties.html"><b>4.3</b> Probability - properties</a></li>
<li><a class="menu-level-2" href="./statistics_prob_theor_practice.html"><b>4.4</b> Probability - theory and..</a></li>
<li><a class="menu-level-2" href="./statistics_prob_distribution.html"><b>4.5</b> Probability distribution</a></li>
<li><a class="menu-level-2" href="./statistics_normal_distribution.html"><b>4.6</b> Normal distribution</a></li>
<li><a class="menu-level-2" href="./statistics_intro_hypothesis_testing.html"><b>4.7</b> Hypothesis testing</a></li>
<li><a class="menu-level-2" href="./statistics_intro_exercises.html"><b>4.8</b> Statistics intro - Exerc..</a></li>
<li><a class="menu-level-2" href="./statistics_intro_exercises_solutions.html"><b>4.9</b> Statistics intro - Solut..</a></li>
<li><a class="menu-level-1" href="./compare_contin_data.html"><b>5</b> Comparisons - continuous d..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_imports.html"><b>5.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_one_samp_ttest.html"><b>5.2</b> One sample Student’s t..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_two_samp_ttest.html"><b>5.3</b> Two samples Student’s ..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_one_way_anova.html"><b>5.4</b> One-way ANOVA</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_post_hoc_tests.html"><b>5.5</b> Post-hoc tests</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_multip_correction.html"><b>5.6</b> Multiplicity correction</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_exercises.html"><b>5.7</b> Exercises - Comparisons ..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_exercises_solutions.html"><b>5.8</b> Solutions - Comparisons ..</a></li>
<li><a class="menu-level-1" href="./compare_categ_data.html"><b>6</b> Comparisons - categorical ..</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_imports.html"><b>6.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_flashback.html"><b>6.2</b> Flashback</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_chisq_test.html"><b>6.3</b> Chi squared test</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_fisher_exact_text.html"><b>6.4</b> Fisher’s exact test</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_bigger_table.html"><b>6.5</b> Bigger table</a></li>
<li><a class="menu-level-2" href="./compare_categ_test_for_independence.html"><b>6.6</b> Test for independence</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_exercises.html"><b>6.7</b> Exercises - Comparisons ..</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_exercises_solutions.html"><b>6.8</b> Solutions - Comparisons ..</a></li>
<li><a class="menu-level-1" href="./assoc_pred.html"><b>7</b> Association and Prediction</a></li>
<li><a class="menu-level-2" href="./assoc_pred_imports.html"><b>7.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./assoc_pred_lin_relation.html"><b>7.2</b> Linear relation</a></li>
<li><a class="menu-level-2" href="./assoc_pred_covariance.html"><b>7.3</b> Covariance</a></li>
<li><a class="menu-level-2" href="./assoc_pred_correlation.html"><b>7.4</b> Correlation</a></li>
<li><a class="menu-level-2" href="./assoc_pred_corr_pitfalls.html"><b>7.5</b> Correlation Pitfalls</a></li>
<li><a class="menu-level-2" href="./assoc_pred_simple_lin_reg.html"><b>7.6</b> Simple Linear Regression</a></li>
<li><a class="menu-level-2" href="./assoc_pred_multiple_lin_reg.html"><b>7.7</b> Multiple Linear Regressi..</a></li>
<li><a class="menu-level-2" href="./assoc_pred_exercises.html"><b>7.8</b> Exercises - Association ..</a></li>
<li><a class="menu-level-2" href="./assoc_pred_exercises_solutions.html"><b>7.9</b> Solutions - Association</a></li>
<li><a class="menu-level-1" href="./time_to_say_goodbye.html"><b>8</b> Time to say goodbye</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="3.4" id="sec:julia_language_functions"><span class="header-section-number">3.4</span> Functions</h2>
<p>Functions are doers, i.e encapsulated pieces of code that do things for us. Optimally, a function should be single minded, i.e. doing one thing only and doing it well. Moreover since they do stuff their names should contain <a href="https://en.wikipedia.org/wiki/Verb">verbs</a> (whereas variables’ names should be composed of <a href="https://en.wikipedia.org/wiki/Noun">nouns</a>).</p>
<p>We already met one of many Julia’s built in functions, namely <code>println</code> (see Section <a href="./julia_is_simple.html#sec:julia_is_simple">2.2</a>). As the name suggests it prints something (like a text) to the <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)">standard output</a>.</p>
<h3 data-number="3.4.1" id="sec:mathematical_functions"><span class="header-section-number">3.4.1</span> Mathematical functions</h3>
<p>We can also define some functions on our own:</p>
<pre class="language-julia"><code>function getRectangleArea(lenSideA::Real, lenSideB::Real)::Real
    return lenSideA * lenSideB
end</code></pre>
<pre class="output"><code>getRectangleArea (generic function with 1 method)</code></pre>
<p>Here I declared Julia’s version of a <a href="https://en.wikipedia.org/wiki/Function_(mathematics)">mathematical function</a>. It is called <code>getRectangleArea</code> and it calculates (surprise, surprise) the <a href="https://en.wikipedia.org/wiki/Rectangle#Formulae">area of a rectangle</a>.</p>
<p>To do that I used a keyword <code>function</code>. The <code>function</code> keyword is followed by the name of the function (<code>getRectangleArea</code>). Inside the parenthesis are arguments of the function. The function accepts two arguments <code>lenSideA</code> (length of one side) and <code>lenSideB</code> (length of the other side) and calculates the area of a rectangle. Both <code>lenSideA</code> and <code>lenSideB</code> are of type <code>Real</code>. It is Julia’s representation of a <a href="https://en.wikipedia.org/wiki/Real_number">real number</a>, it encompasses (its kind of a supertype), among others, <code>Int</code> and <code>Float64</code> that we encountered before. The ending of the first line, <code>)::Real</code>, signifies that the function will return a value of type <code>Real</code>. The stuff that function returns is preceded by the <code>return</code> keyword. The function ends with the <code>end</code> keyword.</p>
<blockquote>
<p><strong><em>Note:</em></strong> A Julia’s function does not need the <code>return</code> keyword since it returns the result of its last expression. Still, I prefer to be explicit.</p>
</blockquote>
<p>Time to run our function and see how it works.</p>
<pre class="language-julia"><code>getRectangleArea(3, 4)</code></pre>
<p>12</p>
<pre class="language-julia"><code>getRectangleArea(1.5, 2)</code></pre>
<p>3.0</p>
<p><em>A quick reference to the topic we discussed in Section <a href="./julia_language_variables.html#sec:julia_optional_type_declaration">3.3.1</a>. Here typing <code>getRectangleArea("three", "three")</code> will produce an error. Now, I can read the error’s message and based on that correct my code so the result is in line with my expectations.</em></p>
<p>Hmm, OK, I got <code>getRectangleArea</code> and what if I need to calculate the <a href="https://en.wikipedia.org/wiki/Square#Perimeter_and_area">area of a square</a>. You got it.</p>
<pre class="language-julia"><code>function getSquareArea(lenSideA::Real)::Real
    return getRectangleArea(lenSideA, lenSideA)
end</code></pre>
<pre class="output"><code>getSquareArea (generic function with 1 method)</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> The argument (<code>lenSideA</code>) of <code>getSquareArea</code> is only known inside the function. Another function can use the same name for its arguments and it will not collide with this one. For instance, <code>getRectangleArea(lenSideA::Real, lenSideB::Real)</code> will receive the same number twice, which <code>getSquareArea</code> knows as <code>lenSideA</code>, but <code>getRectangleArea</code> will see only the numbers (it will receive their copies) and it will name them <code>lenSideA</code> and <code>lenSideB</code> for its own usage.</p>
</blockquote>
<p>Here I can either write its body from scratch (<code>return lendSideA * lenSideA</code>) or reuse (as I did) our previously defined <code>getRectangleArea</code>. Lesson to be learned here, functions can use other functions. This is especially handy if those inner functions are long and complicated. Anyway, let’s see how it works.</p>
<pre class="language-julia"><code>getSquareArea(3)</code></pre>
<p>9</p>
<p>Appears to be working just fine.</p>
<h3 data-number="3.4.2" id="sec:functions_with_generics"><span class="header-section-number">3.4.2</span> Functions with generics</h3>
<p>Now, let’s say I want a function <code>getFirstElt</code> that accepts a vector and returns its first element (vectors and indexing were briefly discussed in Section <a href="./julia_language_variables.html#sec:julia_collections">3.3.5</a>).</p>
<pre class="language-julia"><code># works fine for non-empty vectors
function getFirstElt(vect::Vector{Int})::Int
    return vect[1]
end</code></pre>
<p>It looks OK (test it, e.g. <code>getFirstElt([1, 2, 3]</code>). However, the problem is that it works only with integers (or maybe not, test it out). How to make it work with any type, like <code>getFirstElt(["Eve", "Tom", "Alex"])</code> or <code>getFirstElt([1.1, 2.2, 3.3])</code>?</p>
<p>One way is to declare separate versions of the function for different types of inputs, i.e.</p>
<pre class="language-julia"><code>function getFirstElt(vect::Vector{Int})::Int
    return vect[1]
end

function getFirstElt(vect::Vector{Float64})::Float64
    return vect[1]
end

function getFirstElt(vect::Vector{String})::String
    return vect[1]
end</code></pre>
<pre class="output"><code>getFirstElt (generic function with 3 methods)</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> The function’s name is exactly the same in each case. Julia will choose the correct version (aka method, see the output of the code snippet above) based on the type of the argument (<code>vect</code>) send to the function, e.g. <code>getFirstElt([1, 2, 3])</code>, <code>getFirstElt([1.1, 2, 3.0])</code>, and <code>getFirstElt(["a", "b", "c"])</code> for the three versions above, respectively.</p>
</blockquote>
<p>But that is too much typing (I retyped a few times virtually the same code). The other way is to use no type declarations.</p>
<pre class="language-julia"><code>function getFirstEltVer2(vect)
    return vect[1]
end</code></pre>
<p>It turns out that you don’t have to declare function types in Julia (just like in the case of variables, see Section <a href="./julia_language_variables.html#sec:julia_optional_type_declaration">3.3.1</a>) and a function may work just fine.</p>
<p>Still, a die hard ‘typist’ (if I may call a person this way) would probably use so called generic types, like</p>
<pre class="language-julia"><code>function getFirstEltVer3(vect::Vector{T})::T where T
    return vect[1]
end</code></pre>
<p>Here we said that the vector is composed of elements of type <code>T</code> (<code>Vector{T}</code>) and that the function will return type <code>T</code> (see <code>)::T</code>). By typing <code>where T</code> we let Julia know that <code>T</code> is our custom type that we just made up and it can be any Julia’s built in type whatsoever (but what it is exactly will be determined once the function is used). We needed to say <code>where T</code> otherwise Julia would throw an error (since it wouldn’t be able to find its own built in type <code>T</code>). Anyway, we could replace <code>T</code> with any other letter (or e.g. two letters) of the alphabet (<code>A</code>, <code>D</code>, or whatever) and the code would still work.</p>
<p>One last remark, it is customary to write generic types with a single capital letter. Notice that in comparison to the function with no type declarations (<code>getFirstEltVer2</code>) the version with generics (<code>getFirstEltVer3</code>) is more informative. You know that the function accepts a vector of some elements, and you know that it returns a value of the same type as the elements that build that vector.</p>
<p>Of course, that last function we wrote for fun (it was fun for me, how about you?). In reality Julia already got a function with a similar functionality (see <a href="https://docs.julialang.org/en/v1/base/collections/#Base.first">Base.first</a>).</p>
<blockquote>
<p><strong><em>Note:</em></strong> Functions from Base package, like <code>Base.first</code> mentioned above may be used in a shorter form (without the prefix) like this: <code>first([1, 2, 3, 4])</code>.</p>
</blockquote>
<p>Anyway, as I wrote before if you don’t want to use types then don’t, Julia gives you a choice. When I begun to write my first computer programs, I preferred to use programming languages that didn’t require types. However, nowadays I prefer to use them for the reasons similar to those described in Section <a href="./julia_language_variables.html#sec:julia_optional_type_declaration">3.3.1</a> so be tolerant and bear with me.</p>
<h3 data-number="3.4.3" id="sec:functions_operating_on_structs"><span class="header-section-number">3.4.3</span> Functions operating on structs</h3>
<p>Functions may also work on custom types like the ones created with <code>struct</code>. Do you still remember our <code>Fraction</code> type from Section <a href="./julia_language_variables.html#sec:julia_structs">3.3.8</a>? I hope so.</p>
<p>Let’s say I want to define a function that adds two fractions. I can proceed like so</p>
<pre class="language-julia"><code>function add(f1::Fraction, f2::Fraction)::Fraction
    newDenom::Int = f1.denominator * f2.denominator
    f1NewNom::Int = newDenom / f1.denominator * f1.numerator
    f2NewNom::Int = newDenom / f2.denominator * f2.numerator
    newNom::Int = f1NewNom + f2NewNom
    return Fraction(newNom, newDenom)
end

add(Fraction(1, 3), Fraction(2, 6))</code></pre>
<pre class="output"><code>Fraction(12, 18)</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> The variables <code>newDenom</code>, <code>f1NewNom</code>, <code>f2NewNom</code>, <code>newNom</code> are local, e.g. they are created and exist only inside the function when it is called (like here with <code>add(Fraction(1, 3), Fraction(2, 6))</code>) and do not affect the variables outside the function even if they happened to have the same names.</p>
</blockquote>
<p>Works correctly, but the addition algorithm is not optimal (for now you don’t have to worry too much about the function’s hairy internals). Luckily the built in <code>Rational</code> type (Section <a href="./julia_language_variables.html#sec:julia_structs">3.3.8</a>) is more polished. Observe</p>
<pre class="language-julia"><code># equivalent to: Rational(1, 3) + Rational(2, 6)
1//3 + 2//6</code></pre>
<p>2//3</p>
<p>Much better (<span class="math inline">\(\frac{12}{18} = \frac{12 / 6}{18 / 6} = \frac{2}{3}\)</span>). Of course also other operations like subtraction, multiplication and division work for <code>Rational</code>.</p>
<p>We will meet some functions operating on <code>struct</code>s when we use custom made libraries (e.g. <code>Htests.pvalue</code> that works on the object (struct) returned by <code>Htests.OneWayANOVATest</code> in the upcoming Section <a href="./compare_contin_data_post_hoc_tests.html#sec:compare_contin_data_post_hoc_tests">5.5</a>). Again, for now don’t worry about it too much.</p>
<h3 data-number="3.4.4" id="sec:functions_modifying_arguments"><span class="header-section-number">3.4.4</span> Functions modifying arguments</h3>
<p>Previously (see Section <a href="./julia_language_variables.html#sec:julia_collections">3.3.5</a>) we said that we can change elements of a vector. Sometimes even unintentionally, because, e.g. we may forget that <code>Arrays</code>s/<code>Vector</code>s are assigned/passed by references (as mentioned in Section <a href="./julia_language_variables.html#sec:julia_arrays">3.3.7</a>).</p>
<pre class="language-julia"><code>function wrongReplaceFirstElt(
    ints::Vector{Int}, newElt::Int)::Vector{Int}
    ints[1] = newElt
    return ints
end

xx = [2, 2]
yy = wrongReplaceFirstElt(xx, 3)

# unintentionally we changed xx defined outside a function
(xx, yy)</code></pre>
<pre class="output"><code>([3, 2], [3, 2])</code></pre>
<p>Let’s try to re-write the function that changes the first element improving upon it at the same time.</p>
<pre class="language-julia"><code># the function works fine for non-empty vectors
function replaceFirstElt!(vect::Vector{T}, newElt::T) where T
    vect[1] = newElt
    return nothing
end</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> The function’s name ends with <code>!</code> (exclamation mark). This is one of the Julia’s conventions to mark a function that modifies its arguments.</p>
</blockquote>
<p>In general, you should try to write a function that does not modify its arguments (as modification often causes errors, especially in big programs). However, such modifications are sometimes useful, therefore Julia allows you to do so, but you should always be explicit about it. That is why it is customary to end the name of such a function with <code>!</code> (exclamation mark draws attention).</p>
<p>Additionally, observe that <code>T</code> can be of any type, but we require <code>newElt</code> to be of the same type as the elements in <code>vect</code>. Moreover, since we modify the arguments we wrote <code>return nothing</code> (to be explicit we do not return a thing) and removed returned type after the function’s name, i.e. we used [<code>) where T</code> instead of <code>)::Vector{T} where T</code>].</p>
<p>Let’s see how the function works.</p>
<pre class="language-julia"><code>x = [1, 2, 3]
y = replaceFirstElt!(x, 4)
(x, y)</code></pre>
<pre class="output"><code>([4, 2, 3], nothing)</code></pre>
<p>Let me finish this subsection by mentioning a classical example of a built-in function that modifies its argument. The function is <a href="https://docs.julialang.org/en/v1/base/collections/#Base.push!">push!</a>. It adds elements to a collection (e.g. <code>Array</code>s, or <code>Vector</code>s). Observe:</p>
<pre class="language-julia"><code>xx = [] # empty vector
push!(xx, 1, 2) # now xx is [1, 2]
push!(xx, 3) # now xx is [1, 2, 3]
push!(xx, 4, 5) # now xx is [1, 2, 3, 4, 5]</code></pre>
<p>I mentioned it since that was my favorite way of constructing a vector (to start with an empty vector and add elements one by one with a <code>for</code> loop that we will meet in Section <a href="./julia_language_repetition.html#sec:julia_language_for_loops">3.6.1</a>) back in the day when I started my programming journey. Nowadays I do it a bit differently, but I thought it would be good to mention it in case you find it useful while solving some exercises from this book.</p>
<h3 data-number="3.4.5" id="sec:side_effects_vs_returned_values"><span class="header-section-number">3.4.5</span> Side Effects vs Returned Values</h3>
<p>Notice that so far we encountered two types of Julia’s functions:</p>
<ul>
<li>those that are used for their side effects (like <code>println</code>)</li>
<li>those that return some results (like <code>getRectangleArea</code>)</li>
</ul>
<p>The difference between the two may not be clear while we use the interactive mode. To make it more obvious let’s put them in the script like so:</p>
<pre><code># file: sideEffsVsReturnVals.jl

# you should define a function before you call it
function getRectangleArea(lenSideA::Number, lenSideB::Number)::Number
    return lenSideA * lenSideB
end

println(&quot;Hello World!&quot;)

getRectangleArea(3, 2) # calling the function</code></pre>
<p>After running the code from terminal:</p>
<pre class="bash"><code>cd folder_with_the_sideEffsVsReturnVals.jl
julia sideEffsVsReturnVals.jl</code></pre>
<p>I got printed on the screen:</p>
<pre><code>Hello World!</code></pre>
<p>That’s it. I got only one line of output, the rectangle area seems to be missing. We must remember that a computer does only what we tell it to do, nothing more, nothing less. Here we said:</p>
<ul>
<li>print “Hello World!” to the screen (actually <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)">standard output</a>)</li>
<li>calculate and return the area of the rectangle (but we did nothing with it)</li>
</ul>
<p>In the second case the result went into the void (“If a tree falls in a forest and no one is around to hear it, does it make a sound?”).</p>
<p>If we want to print both pieces of information on the screen we should modify our script to look like:</p>
<pre><code># file: sideEffsVsReturnVals.jl

# you should define a function before you call it
function getRectangleArea(lenSideA::Number, lenSideB::Number)::Number
    return lenSideA * lenSideB
end

println(&quot;Hello World!&quot;)

# println takes 0 or more arguments (separated by commas)
# if necessary arguments are converted to strings and printed
println(&quot;Rectangle area = &quot;, getRectangleArea(3, 2), &quot;[cm^2]&quot;)</code></pre>
<p>Now when we run <code>julia sideEffsVsReturnVals.jl</code> from terminal, we get:</p>
<pre><code>Hello World!
Rectangle area = 6 [cm^2]</code></pre>
<p>More information about functions can be found, e.g. <a href="https://docs.julialang.org/en/v1/manual/functions/">in this section of Julia’s Docs</a>.</p>
<p>If You ever encounter a built in function that you don’t know, you may always search for it in <a href="https://docs.julialang.org/en/v1/">the docs</a> (search box: top left corner of the page).</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="./julia_language_variables.html"><b>3.3</b> Variables</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="./julia_language_decision_making.html"><b>3.5</b> Decision Making</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Bartlomiej Lukaszuk
</div>
</div>
</div>
</body>
</html>