<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Bartlomiej Lukaszuk" />
  <title>Variables - Romeo and Julia, where Romeo is Basic Statistics</title>
  <link rel="stylesheet" href="./style.css"/>
    <script src="./mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("./JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./github.min.css">
<script src="./highlight.min.js"></script>
<script src="./julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="./">Romeo and Julia, where Romeo is Basic Statistics</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="./about.html"><b>1</b> About</a></li>
<li><a class="menu-level-1" href="./why_julia.html"><b>2</b> Why Julia</a></li>
<li><a class="menu-level-2" href="./julia_is_fast.html"><b>2.1</b> Julia is fast</a></li>
<li><a class="menu-level-2" href="./julia_is_simple.html"><b>2.2</b> Julia is simple</a></li>
<li><a class="menu-level-2" href="./jl_pleasure_to_write.html"><b>2.3</b> Pleasure to write</a></li>
<li><a class="menu-level-2" href="./jl_not_mainstream.html"><b>2.4</b> Not mainstream</a></li>
<li><a class="menu-level-2" href="./jl_open_source.html"><b>2.5</b> Julia is free</a></li>
<li><a class="menu-level-1" href="./julia_first_encounter.html"><b>3</b> Julia - first encounter</a></li>
<li><a class="menu-level-2" href="./julia_installation.html"><b>3.1</b> Installation</a></li>
<li><a class="menu-level-2" href="./julia_language_constructs.html"><b>3.2</b> Language Constructs</a></li>
<li><a class="menu-level-2" href="./julia_language_variables.html"><b>3.3</b> Variables</a></li>
<li><a class="menu-level-2" href="./julia_language_functions.html"><b>3.4</b> Functions</a></li>
<li><a class="menu-level-2" href="./julia_language_decision_making.html"><b>3.5</b> Decision Making</a></li>
<li><a class="menu-level-2" href="./julia_language_repetition.html"><b>3.6</b> Repetition</a></li>
<li><a class="menu-level-2" href="./julia_language_libraries.html"><b>3.7</b> Additional libraries</a></li>
<li><a class="menu-level-2" href="./julia_language_exercises.html"><b>3.8</b> Julia - Exercises</a></li>
<li><a class="menu-level-2" href="./julia_language_exercises_solutions.html"><b>3.9</b> Julia - Solutions</a></li>
<li><a class="menu-level-1" href="./statistics_intro.html"><b>4</b> Statistics - introduction</a></li>
<li><a class="menu-level-2" href="./statistics_intro_imports.html"><b>4.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./statistics_intro_probability_definition.html"><b>4.2</b> Probability - definition</a></li>
<li><a class="menu-level-2" href="./statistics_intro_probability_properties.html"><b>4.3</b> Probability - properties</a></li>
<li><a class="menu-level-2" href="./statistics_prob_theor_practice.html"><b>4.4</b> Probability - theory and..</a></li>
<li><a class="menu-level-2" href="./statistics_prob_distribution.html"><b>4.5</b> Probability distribution</a></li>
<li><a class="menu-level-2" href="./statistics_normal_distribution.html"><b>4.6</b> Normal distribution</a></li>
<li><a class="menu-level-2" href="./statistics_intro_hypothesis_testing.html"><b>4.7</b> Hypothesis testing</a></li>
<li><a class="menu-level-2" href="./statistics_intro_exercises.html"><b>4.8</b> Statistics intro - Exerc..</a></li>
<li><a class="menu-level-2" href="./statistics_intro_exercises_solutions.html"><b>4.9</b> Statistics intro - Solut..</a></li>
<li><a class="menu-level-1" href="./compare_contin_data.html"><b>5</b> Comparisons - continuous d..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_imports.html"><b>5.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_one_samp_ttest.html"><b>5.2</b> One sample Student’s t..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_two_samp_ttest.html"><b>5.3</b> Two samples Student’s ..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_one_way_anova.html"><b>5.4</b> One-way ANOVA</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_post_hoc_tests.html"><b>5.5</b> Post-hoc tests</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_multip_correction.html"><b>5.6</b> Multiplicity correction</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_exercises.html"><b>5.7</b> Exercises - Comparisons ..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_exercises_solutions.html"><b>5.8</b> Solutions - Comparisons ..</a></li>
<li><a class="menu-level-1" href="./compare_categ_data.html"><b>6</b> Comparisons - categorical ..</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_imports.html"><b>6.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_flashback.html"><b>6.2</b> Flashback</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_chisq_test.html"><b>6.3</b> Chi squared test</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_fisher_exact_text.html"><b>6.4</b> Fisher’s exact test</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_bigger_table.html"><b>6.5</b> Bigger table</a></li>
<li><a class="menu-level-2" href="./compare_categ_test_for_independence.html"><b>6.6</b> Test for independence</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_exercises.html"><b>6.7</b> Exercises - Comparisons ..</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_exercises_solutions.html"><b>6.8</b> Solutions - Comparisons ..</a></li>
<li><a class="menu-level-1" href="./assoc_pred.html"><b>7</b> Association and Prediction</a></li>
<li><a class="menu-level-2" href="./assoc_pred_imports.html"><b>7.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./assoc_pred_lin_relation.html"><b>7.2</b> Linear relation</a></li>
<li><a class="menu-level-2" href="./assoc_pred_covariance.html"><b>7.3</b> Covariance</a></li>
<li><a class="menu-level-2" href="./assoc_pred_correlation.html"><b>7.4</b> Correlation</a></li>
<li><a class="menu-level-2" href="./assoc_pred_corr_pitfalls.html"><b>7.5</b> Correlation Pitfalls</a></li>
<li><a class="menu-level-2" href="./assoc_pred_simple_lin_reg.html"><b>7.6</b> Simple Linear Regression</a></li>
<li><a class="menu-level-2" href="./assoc_pred_multiple_lin_reg.html"><b>7.7</b> Multiple Linear Regressi..</a></li>
<li><a class="menu-level-2" href="./assoc_pred_exercises.html"><b>7.8</b> Exercises - Association ..</a></li>
<li><a class="menu-level-2" href="./assoc_pred_exercises_solutions.html"><b>7.9</b> Solutions - Association</a></li>
<li><a class="menu-level-1" href="./time_to_say_goodbye.html"><b>8</b> Time to say goodbye</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="3.3" id="sec:julia_language_variables"><span class="header-section-number">3.3</span> Variables</h2>
<p>The way I see it a variable is a box to store some value.</p>
<p>Type</p>
<pre class="language-julia"><code>x = 1</code></pre>
<p>mark it (highlight it with a mouse) and run by pressing <code>Ctrl+Enter</code>.</p>
<p>This creates a variable (an imaginary box) named <code>x</code> (<code>x</code> is a label on the box) that contains the value <code>1</code>. The <code>=</code> operator assigns <code>1</code> (right side) to <code>x</code> (left side) [puts <code>1</code> into the box].</p>
<blockquote>
<p><strong><em>Note:</em></strong> Spaces around mathematical operators like <code>=</code> are usually not necessary. Still, they improve legibility of your code.</p>
</blockquote>
<p>Now, somewhat below type and execute</p>
<pre class="language-julia"><code>x = 2</code></pre>
<p>Congratulations, now the value stored in the box (I mean variable <code>x</code>) is <code>2</code> (the previous value is gone).</p>
<p>Sometimes (usually I do this inside of functions, see Section <a href="./julia_language_functions.html#sec:julia_language_functions">3.4</a>) you may see variables written like that</p>
<pre class="language-julia"><code>z::Int = 4</code></pre>
<p>or</p>
<pre class="language-julia"><code>zz::Float64 = 4.4</code></pre>
<p>The <code>::</code> is a type declaration. Here by using <code>::Int</code> you promise Julia that you will store only <a href="https://en.wikipedia.org/wiki/Integer">integers</a> (like: …, -1, 0, 1, …) in this box. Whereas by typing <code>::Float64</code> you declare to place only <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">floats</a> (like: …, 1.1, 1.0, 0.0, 2.2, 3.14, …) in that box.</p>
<blockquote>
<p><strong><em>Note:</em></strong> You can either explicitly declare a type (with <code>::</code>) or let Julia guess it (when it’s not declared, like in the case of <code>x</code> above). In either situation you can check the type of a variable with <code>typeof</code> function, e.g. <code>typeof(x)</code> or <code>typeof(zz)</code>.</p>
</blockquote>
<h3 data-number="3.3.1" id="sec:julia_optional_type_declaration"><span class="header-section-number">3.3.1</span> Optional type declaration</h3>
<p><strong>In Julia type declaration is optional.</strong> You don’t have to do this, Julia will figure out the types anyway. Still, sometimes it is worth to declare them (explanation in a moment). If you decide to do so, you should declare a variable’s type only once (the time it is first created and initialized with a value).</p>
<p>If you use a variable without a type declaration then you can freely reassign to it values of different types.</p>
<blockquote>
<p><strong><em>Note:</em></strong> In the code snippet below <code>#</code> and all the text to the right of it is a comment, the part that is ignored by a computer but read by a human.</p>
</blockquote>
<pre class="language-julia"><code>a = 1 # type is not declared
a = 2.2 # can assign a value of any other type
# the &quot;Hello&quot; below is a string (a text in a form readable by Julia)
a = &quot;Hello&quot;</code></pre>
<p>But you cannot assign (to a variable) a value of a different type than the one you declared (you must keep your promises). Look at the code below.</p>
<p>This is OK.</p>
<pre class="language-julia"><code>b::Int = 1 # type integer declared
b = 2 # value of type integer delivered</code></pre>
<p>But this is not OK (it’s wrong! it’s wroooong!).</p>
<pre><code>c::Int = 1 # type integer declared
c = 3.3 # broke the promise, float delivered, it will produce an error
c = 3.1 # again, broke the promise, float delivered, expect error</code></pre>
<p>Now a question arises. Why would you want to use a type declaration (like <code>::Int</code> or <code>::Float64</code>) at all?</p>
<p>In general you put values into variables to use them later. Sometimes, you forget what you placed there and may get an unexpected result (it may even go unnoticed for some time). For instance it makes more sense to use integer instead of string for some operations (e.g. I may wish to multiply <code>3</code> by <code>3</code> not <code>"three"</code> by <code>"three"</code>).</p>
<pre class="language-julia"><code>x = 3
x * x # works as you intended</code></pre>
<p>9</p>
<pre class="language-julia"><code>x = &quot;three&quot;
x * x # the result may be surprising</code></pre>
<p>threethree</p>
<blockquote>
<p><strong><em>Note:</em></strong> Julia gives you a standard set of mathematical operators, like addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), division (<code>/</code>) and more (see the <a href="https://docs.julialang.org/en/v1/base/math/#math-ops">docs</a>).</p>
</blockquote>
<p>The latter is an example of a so called <a href="https://docs.julialang.org/en/v1/manual/strings/#man-concatenation">string concatenation</a>, it may be useful (as we will see later in this book), but probably it is not what you wanted.</p>
<p>To avoid such unexpected events (especially if instead of <code>*</code> you use your own function, see Section <a href="./julia_language_functions.html#sec:julia_language_functions">3.4</a>) you would like a guarding angel that watches over you. This is what Julia does when you require it by using type declarations (for now you need to take my word for it).</p>
<p>Moreover, declaring types sometimes may make your code run faster.</p>
<p>Additionally, some <a href="https://en.wikipedia.org/wiki/Integrated_development_environment">IDEs</a> work better (improved code completions, and hints) when you place type declarations in your code.</p>
<p><em>Personally, I like to use type declarations in my own functions (see the upcoming Section <a href="./julia_language_functions.html#sec:julia_language_functions">3.4</a>) to help me reason what they do. At first I write functions without types at all (it’s easier that way). Once I got them running I add the types to them (it us useful for future reference, code maintenance, etc.).</em></p>
<h3 data-number="3.3.2" id="sec:julia_meaningful_variable_names"><span class="header-section-number">3.3.2</span> Meaningful variable names</h3>
<p><strong>Name your variables well</strong>. The variable names I used before are horrible (<em>mea culpa, mea culpa, mea maxima culpa</em>). We use named variables (like <code>x = 1</code>) instead of ‘loose’ variables (you can type <code>1</code> alone in a script file and execute that line) to use them later.</p>
<p>You can use them later in time (reading and editing your code tomorrow or next month/year) or in space (using it 30 or 300 lines below). If so, the names need to be memorable (actually just meaningful will do :D). So whenever possible use: <code>studentAge = 19</code>, <code>bookTitle = "Dune"</code> (grammatical correctness is not that important) instead of <code>x = 19</code>, <code>y = "Dune"</code>.</p>
<p>You may want to check Julia’s Docs for the <a href="https://docs.julialang.org/en/v1/manual/variables/#man-allowed-variable-names">allowed variable names</a> and the recommended <a href="https://docs.julialang.org/en/v1/manual/variables/#Stylistic-Conventions">stylistic conventions</a> (for now, always start with a small letter, and use alphanumeric characters from the Latin alphabet). Personally, I prefer to use <a href="https://en.wikipedia.org/wiki/Camel_case">camelCaseStyle</a> so this is what you’re gonna see here.</p>
<h3 data-number="3.3.3" id="sec:julia_float_comparisons"><span class="header-section-number">3.3.3</span> Floats comparisons</h3>
<p><strong>Be careful with <code>=</code> sign</strong>. In mathematics <code>=</code> means <code>equal to</code> and <code>≠</code> means <code>not equal to</code>. In programming <code>=</code> is usually an assignment operator (see Section <a href="./julia_language_variables.html#sec:julia_language_variables">3.3</a> before). If you want to compare for equality you should use <code>==</code> (for <code>equal to</code>) and (<code>!=</code> for <code>not equal to</code>), examples:</p>
<pre class="language-julia"><code>1 == 1</code></pre>
<p>true</p>
<pre class="language-julia"><code>2 == 1</code></pre>
<p>false</p>
<pre class="language-julia"><code>2.0 != 1.0</code></pre>
<p>true</p>
<pre class="language-julia"><code># comparing float (1.0) with integer (1)
1.0 != 1</code></pre>
<p>false</p>
<pre class="language-julia"><code># comparing integer (2) with float (2.0)
2 == 2.0</code></pre>
<p>true</p>
<p>Be careful though because the comparisons of two floats are sometimes tricky, e.g.</p>
<pre class="language-julia"><code>(0.1 * 3) == 0.3</code></pre>
<p>false</p>
<p>The problem here is not Julia (go ahead, try <code>(0.1 * 3) == 0.3</code> in another programming language), but computers in general. The result is <code>false</code> since some floats cannot be represented exactly as binary numbers (used internally by a computer), just like the fraction <span class="math inline">\(\frac{1}{3}\)</span> cannot be exactly represented in decimal numeral system (<span class="math inline">\(\frac{1}{3}\)</span> = 0.333…). If you are interested in more technical details see <a href="https://stackoverflow.com/questions/8604196/why-0-1-3-0-3">this StackOverflow’s thread</a>. Anyway, this is how my computer sees <code>0.1 * 3</code>:</p>
<pre class="language-julia"><code>0.1 * 3</code></pre>
<p>0.30000000000000004</p>
<p>and <code>0.3</code></p>
<pre class="language-julia"><code>0.3</code></pre>
<p>0.3</p>
<p>The same caution applies to other comparison operators, like:</p>
<ul>
<li><code>x &gt; y</code> (<code>x</code> is greater than <code>y</code>),</li>
<li><code>x &gt;= y</code> (<code>x</code> is greater than or equal to <code>y</code>),</li>
<li><code>x &lt; y</code> (<code>x</code> is less than <code>y</code>),</li>
<li><code>x &lt;= y</code> (<code>x</code> is less than or equal to <code>y</code>).</li>
</ul>
<p><em>We will see how to deal with the lack of precision in comparisons later (see Section <a href="./julia_language_exercises.html#sec:julia_language_exercise2">3.8.2</a>).</em></p>
<h3 data-number="3.3.4" id="sec:julia_other_types"><span class="header-section-number">3.3.4</span> Other types</h3>
<p>There are also other types (see <a href="https://docs.julialang.org/en/v1/manual/types/">Julia’s Docs</a>), but we will use mostly those mentioned in this chapter, i.e.:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">floats</a></li>
<li><a href="https://en.wikipedia.org/wiki/Integer">integers</a></li>
<li><a href="https://en.wikipedia.org/wiki/String_(computer_science)">strings</a></li>
<li><a href="https://en.wikipedia.org/wiki/Boolean_data_type">booleans</a></li>
</ul>
<p>The briefly aforementioned strings contain text of any kind. They are denoted by (optional type declaration) <code>::String</code> and you type them within double quotation marks (<code>"any text"</code>). If you ever want to place <code>"</code> in a string you need to use <code>\</code> (backslash) before it [otherwise Julia will terminate the string on the second <code>"</code> it encounters and throw an error (because it will be confused by the remaining, stray, characters)]. Moreover, if you wish the text to be displayed in the next line (e.g. in a figure’s title like the one in Section <a href="./statistics_intro_hypothesis_testing.html#sec:statistics_intro_tennis_theor_calc">4.7.3</a>) you should place <code>\n</code> in it. For instance:</p>
<pre><code>title = &quot;I enjoy reading\n\&quot;Title of my favorite book\&quot;.&quot;
println(title)</code></pre>
<p>Displays:</p>
<pre><code>I enjoy reading
&quot;Title of my favorite book&quot;.</code></pre>
<p>on the screen.</p>
<p>A string is composed of individual characters (d’ooh!). An individual character (type <code>::Char</code>) is enclosed between single quotation marks. For instance, <code>'a'</code>, <code>'b'</code>, <code>'c'</code>, …, <code>'z'</code> (also uppercase) are all individual characters. Whenever you want to type a single character you got a choice, either use <code>'a'</code> (single <code>Char</code>) or <code>"a"</code> (<code>String</code> composed of one <code>Char</code>). But when typing two or more characters that are ‘glued’ together you must use double quotations (<code>"ab"</code>). In the rest of the book we will focus mostly on strings, still, a bit more knowledge never hurt anyone (or did it?). In Solution to exercise 5 from Section <a href="./compare_contin_data_exercises_solutions.html#sec:compare_contin_data_ex5_solution">5.8.5</a>, we will see how to easily generate a complete alphabet (or a part of it, if you ever need one) with <code>Char</code>s. If you want to know more about the <a href="https://docs.julialang.org/en/v1/manual/strings/">Strings</a> and <a href="https://docs.julialang.org/en/v1/manual/strings/#man-characters">Chars</a> just click the links to the docs that are to be found in this sentence.</p>
<p>The last of the earlier referenced types (boolean) is denoted as <code>::Bool</code> (note that in Julia types’ names by convention start with a capital letter) and can take only two values: <code>true</code> or <code>false</code> (see the results of the comparison operations above in Section <a href="./julia_language_variables.html#sec:julia_float_comparisons">3.3.3</a>). <code>Bool</code>s are often used in decision making in our programs (see the upcoming Section <a href="./julia_language_decision_making.html#sec:julia_language_decision_making">3.5</a>) and can be used with a small set of <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#Boolean-Operators">logical operators</a> like AND (<code>&amp;&amp;</code>)</p>
<pre class="language-julia"><code># &amp;&amp; returns true only if both values are true
# those return false:
# true &amp;&amp; false
# false &amp;&amp; true
# false &amp;&amp; false
# this returns true:
true &amp;&amp; true</code></pre>
<p>true</p>
<p>OR (<code>||</code>)</p>
<pre class="language-julia"><code># || returns true if any value is true
# those return true:
# true || false
# false || true
# true || true
# this returns false:
false || false</code></pre>
<p>false</p>
<p>and NOT (<code>!</code>)</p>
<pre class="language-julia"><code># ! flips the value to the opposite
# returns false: !true
# returns true
!false</code></pre>
<p>true</p>
<h3 data-number="3.3.5" id="sec:julia_collections"><span class="header-section-number">3.3.5</span> Collections</h3>
<p>Not only do variables may store a single value but they can also store their collections. The collection types that we will discuss here are <code>Vector</code> (technically <code>Vector</code> is a one dimensional <code>Array</code> but don’t worry about that now), <code>Array</code> and <code>struct</code> (it is more like a composite type, but again at that moment we will not be bothered by that fact).</p>
<h3 data-number="3.3.6" id="sec:julia_vectors"><span class="header-section-number">3.3.6</span> Vectors</h3>
<pre class="language-julia"><code>myMathGrades = [3.5, 3.0, 3.5, 2.0, 4.0, 5.0, 3.0]</code></pre>
<pre class="output"><code>[3.5, 3.0, 3.5, 2.0, 4.0, 5.0, 3.0]</code></pre>
<p>Here I declared a variable that stores my mock grades.</p>
<p>The variable type is <code>Vector</code> of numbers (each of type <code>Float64</code>, run <code>typeof(myMathGrades)</code> to check it). I could have declared its type explicitly as <code>::Vector{Float64}</code>. Instead I decided to let Julia figure it out.</p>
<p>You can think of a vector as a <a href="https://en.wikipedia.org/wiki/Rectangular_cuboid">rectangular cuboid</a> box with drawers (smaller <a href="https://en.wikipedia.org/wiki/Cube">cube</a> shaped boxes). The drawers are labeled with consecutive numbers (indices) starting at 1 (we will get to that in a moment). The variable contains 7 grades in it, which you can check by typing and executing <code>length(myMathGrades)</code>.</p>
<p>You can retrieve a single element of the vector by typing <code>myMathGrades[i]</code> where <code>i</code> is some integer (the aforementioned index). For instance:</p>
<pre class="language-julia"><code>myMathGrades[3] # returns 3rd element</code></pre>
<p>3.5</p>
<p>or</p>
<pre class="language-julia"><code>myMathGrades[end] # returns last grade
# equivalent to: myMathGrades[7], but here I don&#39;t have to count elements</code></pre>
<p>3.0</p>
<p>Be careful though, if You type a non-existing index like <code>myMathGrades[-1]</code>, <code>myMathGrades[0]</code> or <code>myMathGrades[10]</code> you will get an error (e.g. <code>BoundsError: attempt to access 7-element Vector{Float64} at index [0]</code>).</p>
<p>You can get a slice (a part) of the vector by typing</p>
<pre class="language-julia"><code>myMathGrades[[2, 5]] # returns Vector with 2nd, and 5th element</code></pre>
<pre class="output"><code>[3.0, 4.0]</code></pre>
<p>or</p>
<pre class="language-julia"><code>myMathGrades[[2, 3, 4]] # returns Vector with 2nd, 3rd, and 4th element</code></pre>
<pre class="output"><code>[3.0, 3.5, 2.0]</code></pre>
<p>or simply</p>
<pre class="language-julia"><code>myMathGrades[2:4] # returns Vector with three grades (2nd, 3rd, and 4th)
# the slicing is [inclusive:inclusive]</code></pre>
<pre class="output"><code>[3.0, 3.5, 2.0]</code></pre>
<p>The <code>2:4</code> is Julia’s <a href="https://docs.julialang.org/en/v1/base/math/#Base.range">range</a> generator, with default syntax <code>start:stop</code> (both of which are inclusive). Assume that under the hood it generates a vector (check it by using <a href="https://docs.julialang.org/en/v1/base/collections/#Base.collect-Tuple%7BType,%20Any%7D">collect</a> function, e.g, just run <code>collect(2:4)</code>). So, it gives us the same result as writing <code>myMathGrades[[2, 3, 4]]</code> by hand. However, the range syntax is more convenient (less typing especially for broad ranges). Now, let’s say I want to print every other grade out of 100 grades, then I can go with <code>oneHunderedGrades[1:2:end]</code> and voila, a magic happened thanks to the <code>start:step:stop</code> syntax (<code>collect(1:2:end)</code> returns a vector of indices like <code>[1, 3, 5, 7, ..., 97, 99]</code>).</p>
<p>Interestingly, you can also choose elements of a vector by using <code>Bool</code>s.</p>
<pre class="language-julia"><code>boolIndices = [true, false, true, false, true, false, true]</code></pre>
<pre class="output"><code>Bool[1, 0, 1, 0, 1, 0, 1]</code></pre>
<p>Here, we define a vector composed only of <code>true</code> and <code>false</code> values. The above are printed in their short form as <code>1</code>s and <code>0</code>s, respectively. Now we may use it to get every other element of <code>myMathGrades</code> (actually every element for which the index position is <code>true</code>).</p>
<pre class="language-julia"><code>myMathGrades[boolIndices]</code></pre>
<pre class="output"><code>[3.5, 3.5, 4.0, 3.0]</code></pre>
<p>The above may not look very useful right now (after all we need to type <code>true</code>/<code>false</code> for every index there is), but once we add a bit more syntax it becomes a nice way for data filtering (as we will see in Section <a href="./assoc_pred_corr_pitfalls.html#sec:assoc_pred_corr_pitfalls">7.5</a>).</p>
<p>One last remark, You can change the elements that are in a vector, e.g. like this:</p>
<pre class="language-julia"><code>myMathGrades[1] = 2.0
myMathGrades</code></pre>
<pre class="output"><code>[2.0, 3.0, 3.5, 2.0, 4.0, 5.0, 3.0]</code></pre>
<p>or like that:</p>
<pre class="language-julia"><code>myMathGrades[2:3] = [5.0, 5.0]
myMathGrades</code></pre>
<pre class="output"><code>[2.0, 5.0, 5.0, 2.0, 4.0, 5.0, 3.0]</code></pre>
<p>Again, remember about proper indexing. What you put inside (right side) should be compatible with indexing (left side), e.g <code>myMathGrades[2:3] = [2.0, 2.0, 2.0]</code> will produce an error (placing 3 numbers to 2 slots).</p>
<h3 data-number="3.3.7" id="sec:julia_arrays"><span class="header-section-number">3.3.7</span> Arrays</h3>
<p>A <code>Vector</code> is actually a special case of an <code>Array</code>, a multidimensional structure that holds data. The most familiar (and useful) form of it is a two-dimensional <code>Array</code> (also called <code>Matrix</code>). It has rows and columns. Previously, I stored my math grades in a <code>Vector</code>, but most likely I would like a place to keep my other grades. Here, I create an array that stores my grades from math (column1) and chemistry (column2).</p>
<pre class="language-julia"><code>myGrades = [3.5 3.0; 4.0 3.0; 5.0 2.0]
myGrades</code></pre>
<pre class="output"><code>3×2 Matrix{Float64}:
 3.5  3.0
 4.0  3.0
 5.0  2.0</code></pre>
<p>I separated the values between columns with a space character and indicated a new row with a semicolon. Typing it by hand is not very interesting, but they come in handy as we will see later in the book.</p>
<p>As with vectors I can use indexing to get specific element(s) from a matrix, e.g.</p>
<pre class="language-julia"><code>myGrades[[1, 3], 2] # returns second column (rows 1 and 3) as Vector</code></pre>
<pre class="output"><code>[3.0, 2.0]</code></pre>
<p>or</p>
<pre class="language-julia"><code>myGrades[:, 2] # returns second column (and all rows)</code></pre>
<pre class="output"><code>[3.0, 3.0, 2.0]</code></pre>
<p>Above, the <code>:</code> symbol (when placed alone) means all indices in a row.</p>
<pre class="language-julia"><code>myGrades[1, :] # returns first row (and all columns)</code></pre>
<pre class="output"><code>[3.5, 3.0]</code></pre>
<p>By analogy, here the <code>:</code> symbol (when placed alone) means all indices in a column.</p>
<pre class="language-julia"><code>myGrades[3, 2] # returns a value from third row and second column</code></pre>
<p>2.0</p>
<p>Of course, also <code>Bool</code>s may be used for indexing.</p>
<pre class="language-julia"><code>myGrades[:, [false, true]] # all rows, second column</code></pre>
<pre class="output"><code>3×1 Matrix{Float64}:
 3.0
 3.0
 2.0</code></pre>
<p>Moreover, we can apply the indexing to replace a particular element in a <code>Matrix</code>. For instance.</p>
<pre class="language-julia"><code>myGrades[3, 2] = 5
myGrades</code></pre>
<pre class="output"><code>3×2 Matrix{Float64}:
 3.5  3.0
 4.0  3.0
 5.0  5.0</code></pre>
<p>or</p>
<pre class="language-julia"><code>myGrades[1:2, 1] = [5, 5]
myGrades</code></pre>
<pre class="output"><code>3×2 Matrix{Float64}:
 5.0  3.0
 5.0  3.0
 5.0  5.0</code></pre>
<p>As with a <code>Vector</code> also here you must pay attention to proper indexing.</p>
<p>When dealing with <code>Array</code>s (or <code>Vector</code>s which are one dimensional arrays) one needs to be cautious not to change their contents accidentally.</p>
<p>In case of atomic variables the values are assigned/passed as copies (i.e. a new number <code>3</code> is put to the box, the old number in the variable <code>x</code> is unaffected). Observe.</p>
<pre class="language-julia"><code>x = 2
y = x # y contains the same value as x
y = 3 # y is assigned a new value, x is unaffected

(x, y)</code></pre>
<pre class="output"><code>(2, 3)</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> The <code>(x, y)</code> returns <code>Tuple</code> (see <a href="https://docs.julialang.org/en/v1/manual/functions/#Tuples">Tuple in the docs</a>) and it is there to show both <code>x</code> and <code>y</code> in one line. You may think of <code>Tuple</code> as something similar to <code>Vector</code> but written with parenthesis <code>()</code> instead of square brackets <code>[]</code>. Additionally, you cannot modify elements of a tuple after it was created (so, if you got <code>z = (1, 2, 3)</code>, then <code>z[2]</code> will work fine (since it just returns an element), but <code>z[2] = 8</code> will produce an error). Technically speaking, you could just type <code>x, y</code> and run the line to get a tuple (test it out), but I prefer to use parenthesis to be explicit.</p>
</blockquote>
<p>However, the arrays are assigned/passed as references.</p>
<pre class="language-julia"><code>xx = [2, 2]
yy = xx # yy refers to the same box of drawers as xx
yy[1] = 3 # new value 3 is put to the first drawer of the box pointed by yy

# both xx, and yy are changed, cause both point at the same box of drawers
(xx, yy)</code></pre>
<pre class="output"><code>([3, 2], [3, 2])</code></pre>
<p>As stated in the comments to the code snippet above, here both <code>xx</code> and <code>yy</code> variables point at (reference to) the same box of drawers (imagine the same box of drawers got two labels <code>xx</code> and <code>yy</code> stuck to it next to each other). So, when we change a value in one drawer, then both variables reflect the change. If we want to avoid that we can, e.g. make a <a href="https://docs.julialang.org/en/v1/base/base/#Base.copy">copy</a> of the <code>Vector</code>/<code>Array</code> like so:</p>
<pre class="language-julia"><code>xx = [2, 2]
# yy refers to a different box of drawers
# with the same (copied) numbers inside
yy = copy(xx)
yy[1] = 3 # this does not affect xx

(xx, yy)</code></pre>
<pre class="output"><code>([2, 2], [3, 2])</code></pre>
<h3 data-number="3.3.8" id="sec:julia_structs"><span class="header-section-number">3.3.8</span> Structs</h3>
<p>Another Julia’s type worth mentioning is <a href="https://docs.julialang.org/en/v1/base/base/#struct">struct</a>. It is a composite type (so it contains other type(s) inside).</p>
<p>Let’s say I want to have a thing that resembles fractions that we know from mathematics. It should allow to store the data for numerator and denominator (<span class="math inline">\(\frac{numerator}{denominator}\)</span>). Let’s use <code>struct</code> for that</p>
<pre class="language-julia"><code>struct Fraction
    numerator::Int
    denominator::Int
end

fr1 = Fraction(1, 2)
fr1</code></pre>
<pre class="output"><code>Fraction(1, 2)</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> By convention <code>Struct</code>s’ names start with a capital letter.</p>
</blockquote>
<p>If I ever wanted to get a component of the <code>struct</code> I can use the dot syntax, like so</p>
<pre class="language-julia"><code>fr1.numerator</code></pre>
<p>1</p>
<blockquote>
<p><strong><em>Note:</em></strong> If you type <code>fr1.</code> and press TAB key then you should see a hint with the available field names. You may choose one with arrow keys and confirm it with Enter key.</p>
</blockquote>
<p>or</p>
<pre class="language-julia"><code>fr1.denominator</code></pre>
<p>2</p>
<p>Of course, as you probably have guessed, there is no need to define your own type for fraction since Julia is already equipped with one. It is called <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.Rational">Rational</a>. For convenience the fraction is written as</p>
<pre class="language-julia"><code>1//2 # equivalent to: Rational(1, 2)</code></pre>
<p>1//2</p>
<p>Notice the double slash character (<code>//</code>).</p>
<p>In general, <code>struct</code>s are worth knowing. A lot of libraries (see Section <a href="./julia_language_libraries.html#sec:julia_language_libraries">3.7</a>) define their own <code>struct</code> objects and we may want to extract their content using the dot syntax (as we probably sometimes will in the upcoming sections).</p>
<p>OK, enough about the variables, time to meet functions.</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="./julia_language_constructs.html"><b>3.2</b> Language Constructs</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="./julia_language_functions.html"><b>3.4</b> Functions</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Bartlomiej Lukaszuk
</div>
</div>
</div>
</body>
</html>