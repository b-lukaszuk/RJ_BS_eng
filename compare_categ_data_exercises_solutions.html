<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Bartlomiej Lukaszuk" />
  <title>Solutions - Comparisons of Categorical Data - Romeo and Julia, where Romeo is Basic Statistics</title>
  <link rel="stylesheet" href="./style.css"/>
    <script src="./mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("./JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./github.min.css">
<script src="./highlight.min.js"></script>
<script src="./julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="./">Romeo and Julia, where Romeo is Basic Statistics</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="./about.html"><b>1</b> About</a></li>
<li><a class="menu-level-1" href="./why_julia.html"><b>2</b> Why Julia</a></li>
<li><a class="menu-level-2" href="./julia_is_fast.html"><b>2.1</b> Julia is fast</a></li>
<li><a class="menu-level-2" href="./julia_is_simple.html"><b>2.2</b> Julia is simple</a></li>
<li><a class="menu-level-2" href="./jl_pleasure_to_write.html"><b>2.3</b> Pleasure to write</a></li>
<li><a class="menu-level-2" href="./jl_not_mainstream.html"><b>2.4</b> Not mainstream</a></li>
<li><a class="menu-level-2" href="./jl_open_source.html"><b>2.5</b> Julia is free</a></li>
<li><a class="menu-level-1" href="./julia_first_encounter.html"><b>3</b> Julia - first encounter</a></li>
<li><a class="menu-level-2" href="./julia_installation.html"><b>3.1</b> Installation</a></li>
<li><a class="menu-level-2" href="./julia_language_constructs.html"><b>3.2</b> Language Constructs</a></li>
<li><a class="menu-level-2" href="./julia_language_variables.html"><b>3.3</b> Variables</a></li>
<li><a class="menu-level-2" href="./julia_language_functions.html"><b>3.4</b> Functions</a></li>
<li><a class="menu-level-2" href="./julia_language_decision_making.html"><b>3.5</b> Decision Making</a></li>
<li><a class="menu-level-2" href="./julia_language_repetition.html"><b>3.6</b> Repetition</a></li>
<li><a class="menu-level-2" href="./julia_language_libraries.html"><b>3.7</b> Additional libraries</a></li>
<li><a class="menu-level-2" href="./julia_language_exercises.html"><b>3.8</b> Julia - Exercises</a></li>
<li><a class="menu-level-2" href="./julia_language_exercises_solutions.html"><b>3.9</b> Julia - Solutions</a></li>
<li><a class="menu-level-1" href="./statistics_intro.html"><b>4</b> Statistics - introduction</a></li>
<li><a class="menu-level-2" href="./statistics_intro_imports.html"><b>4.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./statistics_intro_probability_definition.html"><b>4.2</b> Probability - definition</a></li>
<li><a class="menu-level-2" href="./statistics_intro_probability_properties.html"><b>4.3</b> Probability - properties</a></li>
<li><a class="menu-level-2" href="./statistics_prob_theor_practice.html"><b>4.4</b> Probability - theory and..</a></li>
<li><a class="menu-level-2" href="./statistics_prob_distribution.html"><b>4.5</b> Probability distribution</a></li>
<li><a class="menu-level-2" href="./statistics_normal_distribution.html"><b>4.6</b> Normal distribution</a></li>
<li><a class="menu-level-2" href="./statistics_intro_hypothesis_testing.html"><b>4.7</b> Hypothesis testing</a></li>
<li><a class="menu-level-2" href="./statistics_intro_exercises.html"><b>4.8</b> Statistics intro - Exerc..</a></li>
<li><a class="menu-level-2" href="./statistics_intro_exercises_solutions.html"><b>4.9</b> Statistics intro - Solut..</a></li>
<li><a class="menu-level-1" href="./compare_contin_data.html"><b>5</b> Comparisons - continuous d..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_imports.html"><b>5.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_one_samp_ttest.html"><b>5.2</b> One sample Student’s t..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_two_samp_ttest.html"><b>5.3</b> Two samples Student’s ..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_one_way_anova.html"><b>5.4</b> One-way ANOVA</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_post_hoc_tests.html"><b>5.5</b> Post-hoc tests</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_multip_correction.html"><b>5.6</b> Multiplicity correction</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_exercises.html"><b>5.7</b> Exercises - Comparisons ..</a></li>
<li><a class="menu-level-2" href="./compare_contin_data_exercises_solutions.html"><b>5.8</b> Solutions - Comparisons ..</a></li>
<li><a class="menu-level-1" href="./compare_categ_data.html"><b>6</b> Comparisons - categorical ..</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_imports.html"><b>6.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_flashback.html"><b>6.2</b> Flashback</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_chisq_test.html"><b>6.3</b> Chi squared test</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_fisher_exact_text.html"><b>6.4</b> Fisher’s exact test</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_bigger_table.html"><b>6.5</b> Bigger table</a></li>
<li><a class="menu-level-2" href="./compare_categ_test_for_independence.html"><b>6.6</b> Test for independence</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_exercises.html"><b>6.7</b> Exercises - Comparisons ..</a></li>
<li><a class="menu-level-2" href="./compare_categ_data_exercises_solutions.html"><b>6.8</b> Solutions - Comparisons ..</a></li>
<li><a class="menu-level-1" href="./assoc_pred.html"><b>7</b> Association and Prediction</a></li>
<li><a class="menu-level-2" href="./assoc_pred_imports.html"><b>7.1</b> Chapter imports</a></li>
<li><a class="menu-level-2" href="./assoc_pred_lin_relation.html"><b>7.2</b> Linear relation</a></li>
<li><a class="menu-level-2" href="./assoc_pred_covariance.html"><b>7.3</b> Covariance</a></li>
<li><a class="menu-level-2" href="./assoc_pred_correlation.html"><b>7.4</b> Correlation</a></li>
<li><a class="menu-level-2" href="./assoc_pred_corr_pitfalls.html"><b>7.5</b> Correlation Pitfalls</a></li>
<li><a class="menu-level-2" href="./assoc_pred_simple_lin_reg.html"><b>7.6</b> Simple Linear Regression</a></li>
<li><a class="menu-level-2" href="./assoc_pred_multiple_lin_reg.html"><b>7.7</b> Multiple Linear Regressi..</a></li>
<li><a class="menu-level-2" href="./assoc_pred_exercises.html"><b>7.8</b> Exercises - Association ..</a></li>
<li><a class="menu-level-2" href="./assoc_pred_exercises_solutions.html"><b>7.9</b> Solutions - Association</a></li>
<li><a class="menu-level-1" href="./time_to_say_goodbye.html"><b>8</b> Time to say goodbye</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="6.8" id="sec:compare_categ_data_exercises_solutions"><span class="header-section-number">6.8</span> Solutions - Comparisons of Categorical Data</h2>
<p>In this sub-chapter you will find exemplary solutions to the exercises from the previous section.</p>
<h3 data-number="6.8.1" id="sec:compare_categ_data_ex1_solution"><span class="header-section-number">6.8.1</span> Solution to Exercise 1</h3>
<p>An exemplary <code>getContingencyTable</code> could look like this (here, a version that produces output that resembles the result of <code>FreqTables.freqtable</code>):</p>
<pre class="language-julia"><code>function getContingencyTable(
    rowVect::Vector{String},
    colVect::Vector{String},
    rowLabel::String,
    colLabel::String,
    )::Dfs.DataFrame

    rowNames::Vector{String} = sort(unique(rowVect))
    colNames::Vector{String} = sort(unique(colVect))
    pairs::Vector{Tuple{String, String}} = collect(zip(rowVect, colVect))
    pairsCounts::Dict{Tuple{String, String}, Int} = getCounts(pairs)
    labels::String = &quot;↓&quot; * rowLabel * &quot;/&quot; * colLabel * &quot;→&quot;
    df::Dfs.DataFrame = Dfs.DataFrame()
    columns::Dict{String, Vector{Int}} = Dict()

    for cn in colNames
        columns[cn] = [get(pairsCounts, (rn, cn), 0) for rn in rowNames]
    end

    df = Dfs.DataFrame(columns)
    Dfs.insertcols!(df, 1, labels =&gt; rowNames)

    return df
end</code></pre>
<p>Here, as we often do, we start by declaring some of the helpful variables. <code>rowNames</code> and <code>colNames</code> contain all the possible unique groups for each input variable (<code>rowVect</code> and <code>colVect</code>). Then we get all the consecutive pairings that are in the data by using <code>zip</code> and <code>collect</code> functions. For instance <code>collect(zip(["a", "a", "b"], ["x", "y", "x"]))</code> will yield us the following vector of tuples: <code>[("a", "x"), ("a", "y"), ("b", "x")]</code>. The pairs are then sent to <code>getCounts</code> (from Section <a href="./statistics_prob_theor_practice.html#sec:statistics_prob_theor_practice">4.4</a>) to find out how often a given pair occurs.</p>
<p>In the next step we define a variable <code>df</code> (for now it is empty) to hold our final result. We saw in Section <a href="./compare_categ_data_chisq_test.html#sec:compare_categ_data_chisq_test">6.3</a> that a data frame can be created by sending a dictionary to the <code>Dfs.DataFrame</code> function. Therefore, we declare <code>columns</code> (a dictionary) that will hold the count for every column of our contingency table.</p>
<p>We fill the columns one by one with <code>for cn in colNames</code> loop. To get a count for a particular row of a given column (<code>(rn, cn)</code>) we use <code>get</code> function that extracts it from <code>pairsCounts</code>. If the key is not there (a given combination of <code>(rn, cn)</code> does not exist) we return <code>0</code> as a default value. We fill columns by using comprehensions (see Section <a href="./julia_language_repetition.html#sec:julia_language_comprehensions">3.6.3</a>).</p>
<p>Finally, we put our counts (<code>columns</code>) into the data frame (<code>df</code>). Now, we insert a column with <code>rowNames</code> at position <code>1</code> (first column from left) with <code>Dfs.insertcols!</code>.</p>
<p>All that it is left to do is to return the result.</p>
<p>Let’s find out how our <code>getContingencyTable</code> works.</p>
<pre class="language-julia"><code>smokersByProfession = getContingencyTable(
    smoker,
    profession,
    &quot;smoker&quot;,
    &quot;profession&quot;
)
</code></pre>
<div id="tbl:smokersByProfession">
<table>
<caption>Table 7: Number of smokers by profession (fictitious data).</caption>
<thead>
<tr class="header">
<th style="text-align: right;">↓smoker/profession→</th>
<th style="text-align: right;">Lawyer</th>
<th style="text-align: right;">Priest</th>
<th style="text-align: right;">Teacher</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">no</td>
<td style="text-align: right;">14</td>
<td style="text-align: right;">11</td>
<td style="text-align: right;">18</td>
</tr>
<tr class="even">
<td style="text-align: right;">yes</td>
<td style="text-align: right;">17</td>
<td style="text-align: right;">20</td>
<td style="text-align: right;">20</td>
</tr>
</tbody>
</table>
</div>
<p>It appears to work just fine. Let’s swap the inputs and see if we get a consistent result.</p>
<pre class="language-julia"><code>smokersByProfessionTransposed = getContingencyTable(
    profession,
    smoker,
    &quot;profession&quot;,
    &quot;smoker&quot;
)
</code></pre>
<div id="tbl:smokersByProfessionTransposed">
<table>
<caption>Table 8: Number of smokers by profession transposed (fictitious data).</caption>
<thead>
<tr class="header">
<th style="text-align: right;">↓profession/smoker→</th>
<th style="text-align: right;">no</th>
<th style="text-align: right;">yes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Lawyer</td>
<td style="text-align: right;">14</td>
<td style="text-align: right;">17</td>
</tr>
<tr class="even">
<td style="text-align: right;">Priest</td>
<td style="text-align: right;">11</td>
<td style="text-align: right;">20</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Teacher</td>
<td style="text-align: right;">18</td>
<td style="text-align: right;">20</td>
</tr>
</tbody>
</table>
</div>
<p>Looks good. And now for the small data set with possible zeros.</p>
<pre class="language-julia"><code>smokersByProfessionSmall = getContingencyTable(
    smokerSmall,
    professionSmall,
    &quot;smoker&quot;,
    &quot;profession&quot;
)
</code></pre>
<div id="tbl:smokersByProfessionSmall">
<table>
<caption>Table 9: Number of smokers by profession (small data set, fictitious data).</caption>
<thead>
<tr class="header">
<th style="text-align: right;">↓smoker/profession→</th>
<th style="text-align: right;">Lawyer</th>
<th style="text-align: right;">Priest</th>
<th style="text-align: right;">Teacher</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">no</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">1</td>
</tr>
<tr class="even">
<td style="text-align: right;">yes</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">3</td>
</tr>
</tbody>
</table>
</div>
<p>Seems to be OK as well. Of course we can use this function with a data frame, e.g. <code>getContingencyTable(df[!, "col1"], df[!, "col2"], "col1", "col2")</code> or adopt it slightly to take a data frame as an input.</p>
<h3 data-number="6.8.2" id="sec:compare_categ_data_ex2_solution"><span class="header-section-number">6.8.2</span> Solution to Exercise 2</h3>
<p>OK, the most direct solution to the problem (for <code>getColPerc</code>) would be something like</p>
<pre class="language-julia"><code>function getColPerc(m::Matrix{Int})::Matrix{Float64}
    nRows, nCols = size(m)
    percentages:: Matrix{Float64} = zeros(nRows, nCols)
    for c in 1:nCols
        for r in 1:nRows
            percentages[r, c] = m[r, c] / sum(m[:, c])
            percentages[r, c] = round(percentages[r, c] * 100, digits = 2)
        end
    end
    return percentages
end</code></pre>
<p>Here, we begin by extracting the number of rows (<code>nRows</code>) and columns (<code>nCols</code>). We use them right away by defining <code>percentages</code> matrix that will hold our final result (for now it is filled with 0s). Then we use the classical <a href="https://en.wikibooks.org/wiki/Introducing_Julia/Controlling_the_flow#Nested_loops">nested for loops</a> idiom to calculate the percentage for every cell in the matrix/table (we use array indexing we met in Section <a href="./julia_language_variables.html#sec:julia_arrays">3.3.7</a>). For that we divide each count (<code>m[r, c]</code>) by column sum (<code>sum(m[:, c])</code>). Next, we multiply it by 100 (<code>* 100</code>) to change the decimal to percentage. We round the percentage to two decimal points (<code>round</code> and <code>digits = 2</code>).</p>
<p>The algorithm is not super efficient (we calculate <code>sum(m[:, c])</code> separately for every cell) or terse (9 lines of code). Still, it is pretty clear and for small matrices (a few/several rows/cols, that we expect in our input) does the trick.</p>
<p>OK, let’s move to the <code>getRowPerc</code> function.</p>
<pre class="language-julia"><code>function getRowPerc(m::Matrix{Int})::Matrix{Float64}
    nRows, nCols = size(m)
    percentages:: Matrix{Float64} = zeros(nRows, nCols)
    for c in 1:nCols
        for r in 1:nRows
            percentages[r, c] = m[r, c] / sum(m[r, :])
            percentages[r, c] = round(percentages[r, c] * 100, digits = 2)
        end
    end
    return percentages
end</code></pre>
<p>Hmm, it’s almost identical to <code>getColPerc</code> (<code>sum(m[:, c])</code> was replaced with <code>sum(m[r, :])</code>). Let’s remove the code duplication and put it into a single function.</p>
<pre class="language-julia"><code>function getPerc(m::Matrix{Int}, byRow::Bool)::Matrix{Float64}
    nRows, nCols = size(m)
    percentages:: Matrix{Float64} = zeros(nRows, nCols)
    dimSum::Int = 0 # sum in a given dimension of a matrix
    for c in 1:nCols
        for r in 1:nRows
            dimSum = (byRow ? sum(m[r, :]) : sum(m[:, c]))
            percentages[r, c] = m[r, c] / dimSum
            percentages[r, c] = round(percentages[r, c] * 100, digits = 2)
        end
    end
    return percentages
end</code></pre>
<p>Here, we replaced the function specific sums with a more general <code>dimSum</code> (initialized with 0). Then inside the inner for loop we decide which sum to compute (row sum with <code>sum(m[r, :])</code> and column sum with <code>sum(m[:, c])</code>) with a ternary expression from Section <a href="./julia_language_decision_making.html#sec:ternary_expression">3.5.2</a>. OK, enough of tweaking and code optimization, let’s test our new function.</p>
<pre class="language-julia"><code>mEyeColor</code></pre>
<pre class="output"><code>2×2 Matrix{Int64}:
 220  161
 279  320</code></pre>
<p>And now column percentages</p>
<pre class="language-julia"><code>eyeColorColPerc = getPerc(mEyeColor, false)
eyeColorColPerc</code></pre>
<pre class="output"><code>2×2 Matrix{Float64}:
 44.09  33.47
 55.91  66.53</code></pre>
<p>So, based on the data in <code>mEyeColor</code> we see that in the <code>uk</code> (first column) there is roughly 44.09% of people with blue eyes. Whereas in the <code>us</code> (second column) there is roughly 33.47% of people with that eye color.</p>
<p>And now for the row percentages.</p>
<pre class="language-julia"><code>eyeColorRowPerc = getPerc(mEyeColor, true)
eyeColorRowPerc</code></pre>
<pre class="output"><code>2×2 Matrix{Float64}:
 57.74  42.26
 46.58  53.42</code></pre>
<p>So, based on the data in <code>mEyeColor</code> we see that among the investigated groups roughly 57.74% of blue eyed people live in the <code>uk</code> and 42.26% of blue eyed people live in the <code>us</code>.</p>
<p>OK, let’s just quickly make sure our function also works fine for a bigger table.</p>
<pre class="language-julia"><code>mEyeColorFull</code></pre>
<pre class="output"><code>3×2 Matrix{Int64}:
 220  161
 149   78
 130  242</code></pre>
<p>And now column percentages.</p>
<pre class="language-julia"><code>eyeColorColPercFull = getPerc(mEyeColorFull, false)
eyeColorColPercFull</code></pre>
<pre class="output"><code>3×2 Matrix{Float64}:
 44.09  33.47
 29.86  16.22
 26.05  50.31</code></pre>
<p>So, based on the data in <code>mEyeColor</code> we see that in the <code>uk</code> (first column) there is roughly:</p>
<ul>
<li>44.09% of people with blue eyes,</li>
<li>29.86% of people with green eyes, and</li>
<li>26.05% of people with brown eyes.</li>
</ul>
<p>For <code>us</code> (second column) we got:</p>
<ul>
<li>33.47% of people with blue eyes,</li>
<li>16.22% of people with green eyes, and</li>
<li>50.31% of people with brown eyes.</li>
</ul>
<p>Of course, remember that this is all fictitious data inspired by the lecture of <a href="https://en.wikipedia.org/wiki/Eye_color">this Wikipedia’s page</a>.</p>
<p>OK, enough for the task solution. If you want to see a more terse (and mysterious) version of <code>getPerc</code> then go to <a href="https://github.com/b-lukaszuk/RJ_BS_eng/tree/main/code_snippets/ch06">this chapter’s code snippets</a>.</p>
<h3 data-number="6.8.3" id="sec:compare_categ_data_ex3_solution"><span class="header-section-number">6.8.3</span> Solution to Exercise 3</h3>
<p>OK, the most straightforward way to draw a stacked bar plot would be to use <code>Cmk.barplot</code> with <code>stack</code> and <code>color</code> <a href="https://docs.julialang.org/en/v1/manual/functions/#Keyword-Arguments">keyword arguments</a>.</p>
<p>The solution below is slightly different. It allows for greater control over the output and it was created after some try and error.</p>
<pre class="language-julia"><code>import CairoMakie as Cmk

function drawColPerc(df::Dfs.DataFrame,
    dfColLabel::String,
    dfRowLabel::String,
    title::String,
    dfRowColors::Vector{String})::Cmk.Figure

    m::Matrix{Int} = Matrix{Int}(df[:, 2:end])
    columnPerc::Matrix{Float64} = getPerc(m, false)
    nRows, nCols = size(columnPerc)
    colNames::Vector{String} = names(df)[2:end]
    rowNames::Vector{String} = df[1:end, 1]
    xs::Vector{Int} = collect(1:nCols)
    offsets::Vector{Float64} = zeros(nCols)
    curPerc::Vector{Float64} = []
    barplots = []

    fig = Cmk.Figure()
    Cmk.Axis(fig[1, 1],
        title=title,
        xlabel=dfColLabel, ylabel=&quot;% of data&quot;,
        xticks=(xs, colNames),
        yticks=0:10:100)

    for r in 1:nRows
        curPerc = columnPerc[r, :]
        push!(barplots,
            Cmk.barplot!(fig[1, 1], xs, curPerc,
                offset=offsets, color=dfRowColors[r]))
        offsets = offsets .+ curPerc
    end
    Cmk.Legend(fig[1, 2], barplots, rowNames, dfRowLabel)

    return fig
end</code></pre>
<p>We begin by defining a few helpful variables. Most of them are pretty self explanatory and rely on the constructs we met before. The three most enigmatic are <code>offsets</code>, <code>curPerc</code>, and <code>barplots</code>.</p>
<p><code>offsets</code> are the locations on Y-axis where the bottom edges of the bars will be drawn (it is initialized with zeros). <code>curPerc</code> will contain heights of the bars to be drawn. <code>barplots</code> will contain a vector of bar plot objects drawn (it is necessary for adding proper legend with <code>Cmk.Legend</code>). For each row in <code>columnPerc</code> (<code>for r in 1:nRows</code>) we take the percentage of the row and put it into <code>curPerc</code>. Then we draw bars (<code>Cmk.barplot!</code>) of that height that start (their bottom edges) at <code>offsets</code> and are of a color of our choosing (<code>dfRowColors[r]</code>). The list of allowed named colors can be found <a href="https://juliagraphics.github.io/Colors.jl/stable/namedcolors/">here</a>. We append the drawn bars to the <code>bars</code> vector by using <a href="https://docs.julialang.org/en/v1/base/collections/#Base.push!">push!</a> function (we met it in Section <a href="./julia_language_functions.html#sec:functions_modifying_arguments">3.4.4</a>). Then we add <code>curPerc</code> to the offset so that the bottom edges of the next bars will start where the top edges of the previous bars ended.</p>
<p>Once the for loop ended we finish by adding the appropriate legend.</p>
<p>OK, time to test our function</p>
<pre class="language-julia"><code>drawColPerc(dfEyeColorFull, &quot;Country&quot;, &quot;Eye color&quot;,
    &quot;Eye Color distribution by country (column percentages)&quot;,
    [&quot;lightblue1&quot;, &quot;seagreen3&quot;, &quot;peachpuff3&quot;])</code></pre>
<figure>
<img src="./images/ch06ex3v1.png" id="fig:ch06ex3v1" alt="Figure 24: Eye color distribution by country (column percentages, fictitious data)." />
<figcaption aria-hidden="true">Figure 24: Eye color distribution by country (column percentages, fictitious data).</figcaption>
</figure>
<p>I don’t know about you but to me it looks pretty nice.</p>
<p>OK, now we could write <code>drawRowPerc</code> function by modifying our <code>drawColPerc</code> slightly. Finally, after some try and error we could write <code>drawPerc</code> function that combines both those functionalities and reduces code duplication. Without further ado let me fast forward to the definition of <code>drawPerc</code></p>
<pre class="language-julia"><code>function drawPerc(df::Dfs.DataFrame, byRow::Bool,
    dfColLabel::String,
    dfRowLabel::String,
    title::String,
    groupColors::Vector{String})::Cmk.Figure

    m::Matrix{Int} = Matrix{Int}(df[:, 2:end])
    dimPerc::Matrix{Float64} = getPerc(m, byRow)
    nRows, nCols = size(dimPerc)
    colNames::Vector{String} = names(df)[2:end]
    rowNames::Vector{String} = df[1:end, 1]
    ylabel::String = &quot;% of data&quot;
    xlabel::String = (byRow ? dfRowLabel : dfColLabel)
    xs::Vector{Int} = collect(1:nCols)
    yticks::Tuple{Vector{Int},Vector{String}} = (
        collect(0:10:100), map(string, 0:10:100)
    )
    xticks::Tuple{Vector{Int},Vector{String}} = (xs, colNames)

    if byRow
        nRows, nCols = nCols, nRows
        xs = collect(1:nCols)
        colNames, rowNames = rowNames, colNames
        dfColLabel, dfRowLabel = dfRowLabel, dfColLabel
        xlabel, ylabel = ylabel, xlabel
        yticks, xticks = (xs, colNames), yticks
    end

    offsets::Vector{Float64} = zeros(nCols)
    curPerc::Vector{Float64} = []
    barplots = []

    fig = Cmk.Figure()
    Cmk.Axis(fig[1, 1],
        title=title,
        xlabel=xlabel, ylabel=ylabel,
        xticks=xticks,
        yticks=yticks)

    for r in 1:nRows
        curPerc = (byRow ? dimPerc[:, r] : dimPerc[r, :])
        push!(barplots,
            Cmk.barplot!(fig[1, 1], xs, curPerc,
                offset=offsets, color=groupColors[r],
                direction=(byRow ? :x : :y)))
        offsets = offsets .+ curPerc
    end
    Cmk.Legend(fig[1, 2], barplots, rowNames, dfRowLabel)

    return fig
end</code></pre>
<p>Ok, let’s see how it works.</p>
<pre class="language-julia"><code>drawPerc(dfEyeColorFull, true,
    &quot;Country&quot;, &quot;Eye color&quot;,
    &quot;Eye Color distribution by country (row percentages)&quot;,
    [&quot;red&quot;, &quot;blue&quot;])</code></pre>
<figure>
<img src="./images/ch06ex3v2.png" id="fig:ch06ex3v2" alt="Figure 25: Eye color distribution by country (row percentages, fictitious data)." />
<figcaption aria-hidden="true">Figure 25: Eye color distribution by country (row percentages, fictitious data).</figcaption>
</figure>
<p>Pretty, pretty, pretty.</p>
<p>I leave the code in <code>drawPerc</code> for you to decipher. Let me just explain a few new pieces.</p>
<p>In Julia (like in Python) we can define two variables in one go by using the following syntax: <code>a, b = 1, 2</code> (now <code>a = 1</code> and <code>b = 2</code>). Let’s say that later in our program we decided that from now on <code>a</code> should be <code>2</code>, and <code>b</code> should be <code>1</code>. We can swap the variables using the following one line expression: <code>a, b = b, a</code>.</p>
<p>Additionally, <code>drawPerc</code> makes use of the <code>direction</code> keyword argument that accepts <a href="https://docs.julialang.org/en/v1/base/base/#Core.Symbol">symbols</a> <code>:x</code> or <code>:y</code>. It made the output slightly more visually pleasing but also marginally complicated the code. Anyway, <code>direction = :y</code> draws vertical bars (see Figure <a href="#fig:ch06ex3v1">24</a>), whereas <code>direction = :x</code> draws horizontal bars (see Figure <a href="#fig:ch06ex3v2">25</a>).</p>
<p>And that’s it for this exercise.</p>
<h3 data-number="6.8.4" id="sec:compare_categ_data_ex4_solution"><span class="header-section-number">6.8.4</span> Solution to Exercise 4</h3>
<p>OK, let’s start by defining helper functions that we will use to test the assumptions.</p>
<pre class="language-julia"><code>function isSumAboveCutoff(m::Matrix{Int}, cutoff::Int = 49)::Bool
    return sum(m) &gt; cutoff
end

function getExpectedCounts(m::Matrix{Int})::Vector{Float64}
    nObs::Int = sum(m)
    cProbs::Vector{Float64} = [sum(c) / nObs for c in eachcol(m)]
    rProbs::Vector{Float64} = [sum(r) / nObs for r in eachrow(m)]
    probsUnderH0::Vector{Float64} = [
        cp * rp for cp in cProbs for rp in rProbs
        ]
    return probsUnderH0 .* nObs
end

function areAllExpectedCountsAboveCutoff(
    m::Matrix{Int}, cutoff::Float64 = 5.0)::Bool
    expectedCounts::Vector{Float64} = getExpectedCounts(m)
    return map(x -&gt; x &gt;= cutoff, expectedCounts) |&gt; all
end

function areChiSq2AssumptionsOK(m::Matrix{Int})::Bool
    sumGTEQ50::Bool = isSumAboveCutoff(m)
    allExpValsGTEQ5::Bool = areAllExpectedCountsAboveCutoff(m)
    return sumGTEQ50 &amp;&amp; allExpValsGTEQ5
end</code></pre>
<p>There is not much to explain here, since all we did was to gather the functionality we had developed in the previous chapters (e.g. in Section <a href="./compare_categ_data_chisq_test.html#sec:compare_categ_data_chisq_test">6.3</a>).</p>
<p>And now for the tests.</p>
<pre class="language-julia"><code>function runFisherExactTestGetPVal(m::Matrix{Int})::Float64
    @assert (size(m) == (2, 2)) &quot;input matrix must be of size (2, 2)&quot;
    a, c, b, d = m
    return Htests.FisherExactTest(a, b, c, d) |&gt; Htests.pvalue
end

function runCategTestGetPVal(m::Matrix{Int})::Float64
    @assert (size(m) == (2, 2)) &quot;input matrix must be of size (2, 2)&quot;
    if areChiSq2AssumptionsOK(m)
        return Htests.ChisqTest(m) |&gt; Htests.pvalue
    else
        return runFisherExactTestGetPVal(m)
    end
end

function runCategTestGetPVal(df::Dfs.DataFrame)::Float64
    @assert (size(df) == (2, 3)) &quot;input df must be of size (2, 3)&quot;
    return runCategTestGetPVal(Matrix{Int}(df[:, 2:3]))
end</code></pre>
<p>Again, all we did here was to collect the proper functionality we had developed in this chapter (Section <a href="./compare_categ_data.html#sec:compare_categ_data">6</a>) and its sub-chapters. Therefore, I’ll refrain myself from comments. Instead let’s test our newly developed tools.</p>
<pre class="language-julia"><code>round.(
    [
        runCategTestGetPVal(mEyeColor),
        runCategTestGetPVal(mEyeColorSmall),
        runCategTestGetPVal(dfEyeColor)
    ],
    digits = 4
)</code></pre>
<pre class="output"><code>[0.0007, 0.6373, 0.0007]</code></pre>
<p>The functions appear to be working as intended, and the obtained p-values match those from Section <a href="./compare_categ_data_chisq_test.html#sec:compare_categ_data_chisq_test">6.3</a> and Section <a href="./compare_categ_data_fisher_exact_text.html#sec:compare_categ_data_fisher_exact_text">6.4</a>.</p>
<h3 data-number="6.8.5" id="sec:compare_categ_data_ex5_solution"><span class="header-section-number">6.8.5</span> Solution to Exercise 5</h3>
<p>Let’s start by writing a function that will accept a data frame like <code>dfEyeColorFull</code> and return all the possible 2x2 data frames (2 rows and 2 columns with counts).</p>
<pre class="language-julia"><code># previously (ch05) defined function
function getUniquePairs(names::Vector{T})::Vector{Tuple{T,T}} where T
    @assert (length(names) &gt;= 2) &quot;the input must be of length &gt;= 2&quot;
    uniquePairs::Vector{Tuple{T,T}} =
        Vector{Tuple{T,T}}(undef, binomial(length(names), 2))
    currInd::Int = 1
    for i in eachindex(names)[1:(end-1)]
        for j in eachindex(names)[(i+1):end]
            uniquePairs[currInd] = (names[i], names[j])
            currInd += 1
        end
    end
    return uniquePairs
end

function get2x2Dfs(biggerDf::Dfs.DataFrame)::Vector{Dfs.DataFrame}
    nRows, nCols = size(biggerDf)
    @assert ((nRows &gt; 2) || (nCols &gt; 3)) &quot;matrix of counts must be &gt; 2x2&quot;
    rPairs::Vector{Tuple{Int, Int}} = getUniquePairs(collect(1:nRows))
    # counts start from column 2
    cPairs::Vector{Tuple{Int, Int}} = getUniquePairs(collect(2:nCols))
    return [
        biggerDf[[r...], [1, c...]] for r in rPairs for c in cPairs
    ]
end</code></pre>
<p>We begin by copying and pasting <code>getUniquePairs</code> from Section <a href="./compare_contin_data_exercises_solutions.html#sec:compare_contin_data_ex4_solution">5.8.4</a>. We will use it in <code>get2x2Dfs</code>. First we get unique pairs of rows (<code>rPairs</code>). Then we get unique pairs of columns (<code>cPairs</code>). Finally, using nested comprehension and indexing (for reminder see Section <a href="./julia_language_variables.html#sec:julia_arrays">3.3.7</a> and Section <a href="./compare_contin_data_two_samp_ttest.html#sec:compare_contin_data_paired_ttest">5.3.1</a>) we get the vector of all possible 2x2 data frames (actually 2x3 data frames, because first column contains row labels). Since each element of <code>rPairs</code> (<code>r</code>) or <code>cPairs</code> (<code>c</code>) is a tuple, and indexing must be a vector, then we convert one into the other using <code>[r...]</code> and <code>[c...]</code> syntax (e.g. <code>[(1, 2)...]</code> will give us <code>[1, 2]</code>). In the end we get the list of data frames as a result.</p>
<p>OK, let’s write a function to compute p-values (for now unadjusted) for data frames in a vector.</p>
<pre class="language-julia"><code>function runCategTestsGetPVals(
    biggerDf::Dfs.DataFrame
    )::Tuple{Vector{Dfs.DataFrame}, Vector{Float64}}

    overallPVal::Float64 = Htests.ChisqTest(
        Matrix{Int}(biggerDf[:, 2:end])) |&gt; Htests.pvalue
    if (overallPVal &lt;= 0.05)
        dfs::Vector{Dfs.DataFrame} = get2x2Dfs(biggerDf)
        pvals::Vector{Float64} = runCategTestGetPVal.(dfs)
        return (dfs, pvals)
    else
        return ([biggerDf], [overallPVal])
    end
end</code></pre>
<p>The function is rather simple. First, it checks the overall p-value (<code>overallPVal</code>) for the <code>biggerDf</code>. If it is less than or equal to our customary cutoff level (<span class="math inline">\(\alpha = 0.05\)</span>) then we execute <code>runCategTestGetPVal</code> on each possible data frame (<code>dfs</code>) using the dot operator syntax from Section <a href="./julia_language_repetition.html#sec:julia_language_dot_functions">3.6.5</a>. We return a tuple, its first element is a vector of data frames, its second element is a vector of corresponding (uncorrected) p-values. If <code>overallPVal</code> is greater than the cutoff level then we place our <code>biggerDf</code> and its corresponding p-value (<code>overallPVal</code>) into vectors, and place them into a tuple (which is returned).</p>
<p>Time to test our function.</p>
<pre class="language-julia"><code>resultCategTests = runCategTestsGetPVals(dfEyeColorFull)
resultCategTests[1]</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">eyeCol</th>
<th style="text-align: right;">uk</th>
<th style="text-align: right;">us</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">blue</td>
<td style="text-align: right;">220</td>
<td style="text-align: right;">161</td>
</tr>
<tr class="even">
<td style="text-align: right;">green</td>
<td style="text-align: right;">149</td>
<td style="text-align: right;">78</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">eyeCol</th>
<th style="text-align: right;">uk</th>
<th style="text-align: right;">us</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">blue</td>
<td style="text-align: right;">220</td>
<td style="text-align: right;">161</td>
</tr>
<tr class="even">
<td style="text-align: right;">brown</td>
<td style="text-align: right;">130</td>
<td style="text-align: right;">242</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">eyeCol</th>
<th style="text-align: right;">uk</th>
<th style="text-align: right;">us</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">green</td>
<td style="text-align: right;">149</td>
<td style="text-align: right;">78</td>
</tr>
<tr class="even">
<td style="text-align: right;">brown</td>
<td style="text-align: right;">130</td>
<td style="text-align: right;">242</td>
</tr>
</tbody>
</table>
<p>Looking good, and now the corresponding unadjusted p-values.</p>
<pre class="language-julia"><code>resultCategTests[2]</code></pre>
<pre class="output"><code>[0.05384721765961778, 3.5949791158435465e-10, 2.761179458504286e-13]</code></pre>
<p>Once we got it, adjusting the p-values should be a breeze.</p>
<pre class="language-julia"><code>import MultipleTesting as Mt

function adjustPVals(
    multCategTestsResults::Tuple{Vector{Dfs.DataFrame}, Vector{Float64}},
    multCorr::Type{&lt;:Mt.PValueAdjustment}
    )::Tuple{Vector{Dfs.DataFrame}, Vector{Float64}}
    dfs, pvals = multCategTestsResults
    adjPVals::Vector{Float64} = Mt.adjust(pvals, multCorr())
    return (dfs, adjPVals)
end</code></pre>
<p>Yep. All we did here, was to extract the vector of p-values (<code>pvals</code>) and send it as an argument to <code>Mt.adjust</code> for correction. Let’s see how it works (since we are using the <code>Bonferroni</code> method then we expect the adjusted p-values to be 3x greater than the unadjusted ones, see Section <a href="./compare_contin_data_multip_correction.html#sec:compare_contin_data_multip_correction">5.6</a>).</p>
<pre class="language-julia"><code>resultAdjustedCategTests = adjustPVals(resultCategTests, Mt.Bonferroni)
resultAdjustedCategTests[2]</code></pre>
<pre class="output"><code>[0.16154165297885334, 1.078493734753064e-9, 8.283538375512858e-13]</code></pre>
<p>OK, it appears to be working just fine.</p>
<h3 data-number="6.8.6" id="sec:compare_categ_data_ex6_solution"><span class="header-section-number">6.8.6</span> Solution to Exercise 6</h3>
<p>OK, let’s look at an exemplary solution.</p>
<pre class="language-julia"><code>function drawColPerc2(
    biggerDf::Dfs.DataFrame,
    dfColLabel::String,
    dfRowLabel::String,
    title::String,
    dfRowColors::Dict{String,String},
    alpha::Float64=0.05,
    adjMethod::Type{&lt;:Mt.PValueAdjustment}=Mt.Bonferroni)::Cmk.Figure

    multCategTests::Tuple{
        Vector{Dfs.DataFrame},
        Vector{Float64}} = runCategTestsGetPVals(biggerDf)
    multCategTests = adjustPVals(multCategTests, adjMethod)
    dfs, pvals = multCategTests

    fig = Cmk.Figure(size=(800, 400 * length(dfs)))

    for i in eachindex(dfs)
        m::Matrix{Int} = Matrix{Int}(dfs[i][:, 2:end])
        columnPerc::Matrix{Float64} = getPerc(m, false)
        nRows, nCols = size(columnPerc)
        colNames::Vector{String} = names(dfs[i])[2:end]
        rowNames::Vector{String} = dfs[i][1:end, 1]
        xs::Vector{Int} = collect(1:nCols)
        offsets::Vector{Float64} = zeros(nCols)
        curPerc::Vector{Float64} = []
        barplots = []

        Cmk.Axis(fig[i, 1],
            title=title,
            xlabel=dfColLabel, ylabel=&quot;% of data&quot;,
            xticks=(xs, colNames),
            yticks=0:10:100)

        for r in 1:nRows
            curPerc = columnPerc[r, :]
            push!(barplots,
                Cmk.barplot!(fig[i, 1], xs, curPerc,
                    offset=offsets,
                    color=get(dfRowColors, rowNames[r], &quot;black&quot;),
                    strokewidth=(pvals[i] &lt;= alpha) ? 2 : 0))
            offsets = offsets .+ curPerc
        end
        Cmk.Legend(fig[i, 2], barplots, rowNames, dfRowLabel)
    end

    return fig
end</code></pre>
<p>The function definition differs slightly from the original <code>drawColPerc</code>. Of note we changed the <code>colors</code> parameter from <code>Vector{String}</code> to <code>Dict{String, String}</code> (a mapping between row name in column 1 and color by which it will be represented on the graph). Of course, we added two more parameters <code>alpha</code> and <code>adjMethod</code>.</p>
<p>First, we run multiple categorical tests (<code>runCategTestsGetPVals</code>) and adjust the obtained p-values (<code>adjustPVals</code>) using functionality developed earlier (Section <a href="./compare_categ_data_exercises_solutions.html#sec:compare_categ_data_ex5_solution">6.8.5</a>). Then we, define the figure object with a desired size (<code>size=(widthPixels, heightPixels)</code>) adjusted by number of subplots in the figure (<code>* length(dfs)</code>).</p>
<p>The next step is pretty simple, basically we enclose the previously developed code from <code>drawColPerc</code> in a for loop (<code>for i in eachindex(dfs)</code>) that draws consecutive data frames as a stacked bar plots in a separate rows of the figure. If a statistically significant difference for a data frame was detected (<code>pvals[i] &lt;= alpha</code>) we add a stroke (<code>strokewidth</code>) to the bar plot.</p>
<p>Time to see how it works.</p>
<pre><code>drawColPerc2(dfEyeColorFull, &quot;Country&quot;, &quot;Eye color&quot;, &quot;Eye color by country&quot;,
    Dict(&quot;blue&quot; =&gt; &quot;lightblue1&quot;,
        &quot;green&quot; =&gt; &quot;seagreen3&quot;,
        &quot;brown&quot; =&gt; &quot;peachpuff3&quot;))</code></pre>
<figure>
<img src="./images/ch06ex6.png" id="fig:ch06ex6" alt="Figure 26: Eye color distribution by country (column percentages, fictitious data). Stroke denotes statistically significant difference (p \leq 0.05)." />
<figcaption aria-hidden="true">Figure 26: Eye color distribution by country (column percentages, fictitious data). Stroke denotes statistically significant difference (p <span class="math inline">\(\leq\)</span> 0.05).</figcaption>
</figure>
<p>It looks quite OK + it allows us to quickly judge which eye colors distributions differ one from another. For a more complicated layout we should probably follow the guidelines contained in the <a href="https://docs.makie.org/stable/tutorials/layout-tutorial/">Layout Tutorial</a>.</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="./compare_categ_data_exercises.html"><b>6.7</b> Exercises - Comparisons ..</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="./assoc_pred.html"><b>7</b> Association and Prediction</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Bartlomiej Lukaszuk
</div>
</div>
</div>
</body>
</html>